class Renderer{constructor(canvas){this._canvas=canvas;this._objects=[];this._clearColor={r:0,g:56/255,b:101/255,a:1};}
async init(){if(!navigator.gpu){throw Error("WebGPU is not supported in this browser.");}
const adapter=await navigator.gpu.requestAdapter();if(!adapter){throw Error("Couldn't request WebGPU adapter.");}
this._device=await adapter.requestDevice();this._context=this._canvas.getContext("webgpu");this._canvasFormat=navigator.gpu.getPreferredCanvasFormat();this._context.configure({device:this._device,format:this._canvasFormat,});this.resizeCanvas();window.addEventListener('resize',this.resizeCanvas.bind(this));}
resizeCanvas(){const devicePixelRatio=window.devicePixelRatio||1;const width=window.innerWidth*devicePixelRatio;const height=window.innerHeight*devicePixelRatio;this._canvas.width=width;this._canvas.height=height;this._canvas.style.width=`${window.innerWidth}px`;this._canvas.style.height=`${window.innerHeight}px`;this._canvas.style.transformOrigin="center";this.render();}
async appendSceneObject(obj){await obj.init();this._objects.push(obj);}
renderToSelectedView(outputView){for(const obj of this._objects){obj?.updateGeometry();}
let encoder=this._device.createCommandEncoder();const pass=encoder.beginRenderPass({colorAttachments:[{view:outputView,clearValue:this._clearColor,loadOp:"clear",storeOp:"store",}]});for(const obj of this._objects){obj?.render(pass);}
pass.end();const computePass=encoder.beginComputePass();for(const obj of this._objects){obj?.compute(computePass);}
computePass.end();const commandBuffer=encoder.finish();this._device.queue.submit([commandBuffer]);}
render(){this.renderToSelectedView(this._context.getCurrentTexture().createView());}}
class RayTracer extends Renderer{constructor(canvas){super(canvas);this._tracer=null;}
async init(){if(!navigator.gpu){throw Error("WebGPU is not supported in this browser.");}
const adapter=await navigator.gpu.requestAdapter();if(!adapter){throw Error("Couldn't request WebGPU adapter.");}
this._device=await adapter.requestDevice();this._context=this._canvas.getContext("webgpu");this._canvasFormat="rgba8unorm";this._context.configure({device:this._device,format:this._canvasFormat,});this._shaderModule=this._device.createShaderModule({label:"Ray Tracer Shader",code:`
      @vertex
      fn vertexMain(@builtin(vertex_index) vIdx: u32) -> @builtin(position) vec4f {
        var pos = array<vec2f, 6>(
          vec2f(-1, -1), vec2f(1, -1), vec2f(-1, 1),
          vec2f(-1, 1), vec2f(1, -1), vec2f(1, 1)
        );
        return vec4f(pos[vIdx], 0, 1);
      }
      
      @group(0) @binding(0) var inTexture: texture_2d<f32>;
      @group(0) @binding(1) var inSampler: sampler;
      @group(0) @binding(2) var<uniform> imgSize: vec2f;
      
      @fragment
      fn fragmentMain(@builtin(position) fragCoord: vec4f) -> @location(0) vec4f {
        let uv = fragCoord.xy / imgSize; // vec2f(textureDimensions(inTexture, 0));
        return textureSample(inTexture, inSampler, uv);
      }
      `});this._outputSizeBuffer=this._device.createBuffer({label:"Ray Tracer output size buffer",size:8,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,});this._pipeline=this._device.createRenderPipeline({label:"Ray Tracer Pipeline",layout:"auto",vertex:{module:this._shaderModule,entryPoint:"vertexMain",},fragment:{module:this._shaderModule,entryPoint:"fragmentMain",targets:[{format:this._canvasFormat}]}});this._sampler=this._device.createSampler({label:"Ray Tracer Sampler",magFilter:"linear",minFilter:"linear"});this.resizeCanvas();window.addEventListener('resize',this.resizeCanvas.bind(this));}
resizeCanvas(){const devicePixelRatio=window.devicePixelRatio||1;const width=window.innerWidth*devicePixelRatio;const height=window.innerHeight*devicePixelRatio;const ratio=width/height;const tgtHeight=height;let imgSize={width:tgtHeight*ratio,height:tgtHeight};this._offScreenTexture=this._device.createTexture({size:imgSize,format:this._canvasFormat,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING,});if(this._tracer){this._tracer._imgWidth=this._offScreenTexture.width;this._tracer._imgHeight=this._offScreenTexture.height;this._tracer.updateGeometry();this._tracer.createBindGroup(this._offScreenTexture);}
this._bindGroup=this._device.createBindGroup({label:"Ray Tracer Renderer Bind Group",layout:this._pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:this._offScreenTexture.createView()},{binding:1,resource:this._sampler},{binding:2,resource:{buffer:this._outputSizeBuffer}}],});super.resizeCanvas();this._device.queue.writeBuffer(this._outputSizeBuffer,0,new Float32Array([width,height]));}
async setTracerObject(obj){await obj.init();obj._imgWidth=this._offScreenTexture.width;obj._imgHeight=this._offScreenTexture.height;obj.updateGeometry();this._tracer=obj;this._tracer.createBindGroup(this._offScreenTexture);}
render(){if(this._tracer){let encoder=this._device.createCommandEncoder();const computePass=encoder.beginComputePass();this._tracer.compute(computePass);computePass.end();this._device.queue.submit([encoder.finish()]);}
let encoder=this._device.createCommandEncoder();const pass=encoder.beginRenderPass({colorAttachments:[{view:this._context.getCurrentTexture().createView(),clearValue:this._clearColor,loadOp:"clear",storeOp:"store",}]});pass.setPipeline(this._pipeline);pass.setBindGroup(0,this._bindGroup);pass.draw(6);pass.end();this._device.queue.submit([encoder.finish()]);}}
class StandardTextObject{constructor(inputText,right='',left='10',top='10',spacing=5,textFont='18px Arial'){this._textFont=textFont;this._lineSpacing=spacing;this._textCanvas=document.createElement('canvas');this._textContext=this._textCanvas.getContext('2d');this.updateTextRegion(inputText);this.updateText(inputText);this._textCanvas.style.position='absolute';if(right!=''){this._textCanvas.style.right=right+'px';}else{this._textCanvas.style.left=left+'px';}
this._textCanvas.style.top=top+'px';this._textCanvas.style.border='1px solid red';document.body.appendChild(this._textCanvas);}
toggleVisibility(){this._textCanvas.hidden=!this._textCanvas.hidden;}
updateTextRegion(newText){this._textContext.font=this._textFont;this._lines=newText.split('\n');this._width=Math.max(...this._lines.map(line=>this._textContext.measureText(line).width));const match=this._textFont.match(/(\d+)px/);if(match){this._fontSize=parseInt(match[1],10);}
else{this._fontSize=18;this._textFont="18px Arial";}
this._height=this._lines.length*(this._fontSize+this._lineSpacing);this._paddingx=5;this._paddingtop=3;this._canvasWidth=Math.ceil(this._width+this._paddingx*2);this._canvasHeight=Math.ceil(this._height+this._paddingtop);this._textCanvas.width=this._canvasWidth;this._textCanvas.height=this._canvasHeight;this._textContext.font=this._textFont;this._textContext.textBaseline='top';}
updateText(newText){this._lines=newText.split('\n');this._textContext.fillStyle='rgba(1, 1, 1, 0.5)';this._textContext.clearRect(0,0,this._canvasWidth,this._canvasHeight);this._textContext.fillRect(0,0,this._canvasWidth,this._canvasHeight);this._textContext.fillStyle='white';this._lines.forEach((line,idx)=>{const x=this._paddingx;const y=this._paddingtop+idx*(this._fontSize+this._lineSpacing);this._textContext.fillText(line,x,y);});}}
class SceneObject{static _objectCnt=0;constructor(device,canvasFormat){if(this.constructor==SceneObject){throw new Error("Abstract classes can't be instantiated.");}
this._device=device;this._canvasFormat=canvasFormat;SceneObject._objectCnt+=1;}
getName(){return this.constructor.name+" "+SceneObject._objectCnt.toString();}
async init(){await this.createGeometry();await this.createShaders();await this.createRenderPipeline();await this.createComputePipeline();}
async createGeometry(){throw new Error("Method 'createGeometry()' must be implemented.");}
updateGeometry(){}
loadShader(filename){return new Promise((resolve,reject)=>{const xhttp=new XMLHttpRequest();xhttp.open("GET",filename);xhttp.setRequestHeader("Cache-Control","no-cache, no-store, max-age=0");xhttp.onload=function(){if(xhttp.readyState===XMLHttpRequest.DONE&&xhttp.status===200){resolve(xhttp.responseText);}
else{reject({status:xhttp.status,statusText:xhttp.statusText});}};xhttp.onerror=function(){reject({status:xhttp.status,statusText:xhttp.statusText});};xhttp.send();});}
async createShaders(){throw new Error("Method 'createShaders()' must be implemented.");}
async createRenderPipeline(){throw new Error("Method 'createRenderPipeline()' must be implemented.");}
render(pass){throw new Error("Method 'render(pass)' must be implemented.");}
async createComputePipeline(){throw new Error("Method 'createComputePipeline()' must be implemented.");}
compute(pass){throw new Error("Method 'compute(pass)' must be implemented.");}}
class RayTracingObject extends SceneObject{async createGeometry(){}
async createShaders(){let shaderCode=await this.loadShader("/shaders/optimized_tracenothing.wgsl");this._shaderModule=this._device.createShaderModule({label:" Shader "+this.getName(),code:shaderCode,});}
updateGeometry(){}
async createRenderPipeline(){}
render(pass){}
async createComputePipeline(){this._computePipeline=this._device.createComputePipeline({label:"Ray Tracing Pipeline "+this.getName(),layout:"auto",compute:{module:this._shaderModule,entryPoint:"computeMain",}});}
createBindGroup(outTexture){this._bindGroup=this._device.createBindGroup({label:"Ray Tracing Bind Group",layout:this._computePipeline.getBindGroupLayout(0),entries:[{binding:0,resource:outTexture.createView()}],});this._wgWidth=Math.ceil(outTexture.width);this._wgHeight=Math.ceil(outTexture.height);}
compute(pass){pass.setPipeline(this._computePipeline);pass.setBindGroup(0,this._bindGroup);pass.dispatchWorkgroups(Math.ceil(this._wgWidth/16),Math.ceil(this._wgHeight/16));}}
class VolumeByteIO{constructor(){}
static readBinary(filename){return new Promise((resolve,reject)=>{const xhttp=new XMLHttpRequest();xhttp.open("GET",filename);xhttp.setRequestHeader("Cache-Control","no-cache, no-store, max-age=0");xhttp.responseType='arraybuffer';xhttp.onload=function(){if(xhttp.readyState===XMLHttpRequest.DONE&&xhttp.status===200){resolve(xhttp.response);}
else{reject(new Error('Error loading volume byte data: '+xhttp.status));}}
xhttp.onerror=function(){reject(new Error('Network error loading volume byte data'));}
xhttp.send();});}
static readBytes(view,offset,isLittle,type){switch(type){case'char':return[view.getInt8(offset,1)];break;case'uchar':return[view.getUint8(offset,1)];break;case'short':return[view.getInt16(offset,isLittle),2];break;case'ushort':return[view.getUint16(offset,isLittle),2];break;case'int':return[view.getInt32(offset,isLittle),4];break;case'uint':return[view.getUint32(offset,isLittle),4];break;case'float':return[view.getFloat32(offset,isLittle),4];break;case'double':return[view.getFloat64(offset,isLittle),8];break;}}
static async read(filename){let binarydata=await VolumeByteIO.readBinary(filename);let text=new TextDecoder().decode(binarydata);const dims=[181,217,181];const sizes=[1,1,1];const data=[];let offset=0;let view=new DataView(binarydata);for(let i=0;i<dims.reduce((s,val)=>s*val,1);++i){const[value,delta]=VolumeByteIO.readBytes(view,offset,true,'short');data.push(value);offset+=delta;}
return[dims,sizes,data];}
static isLittleEndian(){const buffer=new ArrayBuffer(2);const view=new DataView(buffer);view.setInt16(0,256,true);return view.getInt8(0)===0;}
static async write(volume,filename){const volumeData=new Uint8Array(volume.data.length*2);volume.data.forEach((value,index)=>{const view=new Uint16Array([value]);volumeData.set(new Uint8Array(view.buffer),index*2);});const blob=new Blob([volumeData],{type:'application/octet-stream'});const a=document.createElement('a');a.href=URL.createObjectURL(blob);a.download='download.raws';a.click();URL.revokeObjectURL(a.href);}}
class VolumeData{constructor(filename){this._filename=filename;}
async init(){const[dims,sizes,data]=await VolumeByteIO.read(this._filename);this._dims=dims;this._sizes=sizes;this._data=data;}}
class PerlinNoise{constructor(){this.gradientPermutation();}
gradientPermutation(){this._permutation=Array.from({length:256},(_,i)=>i);for(let i=this._permutation.length-1;i>0;--i){const j=Math.floor(Math.random()*(i+1));[this._permutation[i],this._permutation[j]]=[this._permutation[j],this._permutation[i]];}}
gradient(hashvalue,x,y=0,z=0){switch(hashvalue&15){case 0:case 12:return x+y;case 1:case 13:return-x+y;case 2:case 14:return x-y;case 3:case 15:return-x-y;case 4:return x+z;case 5:return-x+z;case 6:return x-z;case 7:return-x-z;case 8:return y+z;case 9:return-y+z;case 10:return y-z;case 11:return-y-z;}}
noise1d(x){const fade=(t)=>{return t*t*t*(t*(t*6-15)+10)};const interpolate=(src,dst,t)=>{return src*t+dst*(1-t)};const ix=Math.floor(x)&255;const ixx=(ix+1)&255;x-=Math.floor(x);let t=fade(x);let src=this._permutation[ix];let dst=this._permutation[ixx];let srcGrad=this.gradient(src,x);let dstGrad=this.gradient(dst,x-1);return interpolate(srcGrad,dstGrad,t);}
noise2d(x,y){const fade=(t)=>{return t*t*t*(t*(t*6-15)+10)};const interpolate=(src,dst,t)=>{return src*t+dst*(1-t)};const gradient=(hash,x,y)=>{const h=hash&3;const u=h&1?x:-x;const v=h&2?y:-y;return u+v;};const ix=Math.floor(x)&255;const ixx=(ix+1)&255;const iy=Math.floor(y)&255;const iyy=(iy+1)&255;x-=Math.floor(x);y-=Math.floor(y);let tx=fade(x);let ty=fade(y);let a=this._permutation[ix]+iy;let b=this._permutation[ixx]+iy;let grad00=gradient(this._permutation[a],x,y);let grad10=gradient(this._permutation[b],x-1,y);let grad01=gradient(this._permutation[a+1],x,y-1);let grad11=gradient(this._permutation[b+1],x-1,y-1);let interpX1=interpolate(grad00,grad10,tx);let interpX2=interpolate(grad01,grad11,tx);return interpolate(interpX1,interpX2,ty);}
noise3d(x,y,z){const fade=(t)=>{return t*t*t*(t*(t*6-15)+10)};const interpolate=(src,dst,t)=>{return src*t+dst*(1-t)};const gradient=(hash,x,y,z)=>{const h=hash&15;const u=h<8?x:y;const v=h<4?y:(h===12||h===14?x:z);return((h&1)===0?u:-u)+((h&2)===0?v:-v);};const ix=Math.floor(x)&255;const ixx=(ix+1)&255;const iy=Math.floor(y)&255;const iyy=(iy+1)&255;const iz=Math.floor(z)&255;const izz=(iz+1)&255;x-=Math.floor(x);y-=Math.floor(y);z-=Math.floor(z);let tx=fade(x);let ty=fade(y);let tz=fade(z);const p=this._permutation;const A=p[ix]+iy,AA=p[A]+iz,AB=p[A+1]+iz;const B=p[ixx]+iy,BA=p[B]+iz,BB=p[B+1]+iz;const grad000=gradient(p[AA],x,y,z);const grad100=gradient(p[BA],x-1,y,z);const grad010=gradient(p[AB],x,y-1,z);const grad110=gradient(p[BB],x-1,y-1,z);const grad001=gradient(p[AA+1],x,y,z-1);const grad101=gradient(p[BA+1],x-1,y,z-1);const grad011=gradient(p[AB+1],x,y-1,z-1);const grad111=gradient(p[BB+1],x-1,y-1,z-1);const lerpX00=interpolate(grad000,grad100,tx);const lerpX10=interpolate(grad010,grad110,tx);const lerpX01=interpolate(grad001,grad101,tx);const lerpX11=interpolate(grad011,grad111,tx);const lerpY0=interpolate(lerpX00,lerpX10,ty);const lerpY1=interpolate(lerpX01,lerpX11,ty);return interpolate(lerpY0,lerpY1,tz);}
octaveNoise2d(x,y,freq=0.005,A=1,H=0.5,octaves=4,lacunarity=2){let noise=0;let maxVal=0;let frequency=freq;for(let i=0;i<octaves;i++){let gain=Math.pow(freq,-H*i);A=A*gain;maxVal+=A;noise+=this.noise2d(x*frequency,y*frequency)*A;frequency*=lacunarity;}
return noise/maxVal;}}
class FogData{constructor(){this._dims=[64,64,64];this._sizes=[2,2,2];}
async init(){this._perlinNoise=new PerlinNoise();this._data=Array(this._dims[0]*this._dims[1]*this._dims[2]).fill(0);for(let z=0;z<this._dims[2];++z){for(let y=0;y<this._dims[1];++y){for(let x=0;x<this._dims[0];++x){let noise=(this._perlinNoise.noise3d(x,y,z)+2)/4;this._data[z*(this._dims[0]*this._dims[1])+y*this._dims[0]+x]=noise;}}}}};class VolumeRenderingSimpleObject extends RayTracingObject{constructor(device,canvasFormat,camera){super(device,canvasFormat);this._volume=new VolumeData('/assets/brainweb-t1-1mm-pn0-rf0.raws');this._camera=camera;this._mode=0;}
async createGeometry(){await this._volume.init();this._cameraBuffer=this._device.createBuffer({label:"Camera "+this.getName(),size:this._camera._pose.byteLength+this._camera._focal.byteLength+this._camera._resolutions.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,});this._device.queue.writeBuffer(this._cameraBuffer,0,this._camera._pose);this._device.queue.writeBuffer(this._cameraBuffer,this._camera._pose.byteLength,this._camera._focal);this._device.queue.writeBuffer(this._cameraBuffer,this._camera._pose.byteLength+this._camera._focal.byteLength,this._camera._resolutions);this._volumeBuffer=this._device.createBuffer({label:"Volume "+this.getName(),size:(this._volume._dims.length+this._volume._sizes.length+2)*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,});this._device.queue.writeBuffer(this._volumeBuffer,0,new Float32Array([...this._volume._dims,0,...this._volume._sizes,0]));this._dataBuffer=this._device.createBuffer({label:"Data "+this.getName(),size:this._volume._data.length*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,});this._device.queue.writeBuffer(this._dataBuffer,0,new Float32Array(this._volume._data));this._modeBuffer=this._device.createBuffer({label:"Mode "+this.getName(),size:16,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,});this._device.queue.writeBuffer(this._modeBuffer,0,new Uint32Array([this._mode]));}
updateGeometry(){this._camera.updateSize(this._imgWidth,this._imgHeight);this._device.queue.writeBuffer(this._cameraBuffer,this._camera._pose.byteLength+this._camera._focal.byteLength,this._camera._resolutions);}
updateCameraPose(){this._device.queue.writeBuffer(this._cameraBuffer,0,this._camera._pose);}
updateCameraFocal(){this._device.queue.writeBuffer(this._cameraBuffer,this._camera._pose.byteLength,this._camera._focal);}
async updateMode(){console.log(this._mode);this._device.queue.writeBuffer(this._modeBuffer,0,new Uint32Array([this._mode]));}
async createShaders(){let shaderCode=await this.loadShader("/shaders/optimized_traceVolumeFull.wgsl");this._shaderModule=this._device.createShaderModule({label:" Shader "+this.getName(),code:shaderCode,});this._bindGroupLayout=this._device.createBindGroupLayout({label:"Ray Trace Volume Layout "+this.getName(),entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:3,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:this._canvasFormat}},{binding:4,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}]});this._pipelineLayout=this._device.createPipelineLayout({label:"Ray Trace Volume Pipeline Layout",bindGroupLayouts:[this._bindGroupLayout],});}
async createComputePipeline(){this._computePipeline=this._device.createComputePipeline({label:"Ray Trace Volume Orthogonal Pipeline "+this.getName(),layout:this._pipelineLayout,compute:{module:this._shaderModule,entryPoint:"computeOrthogonalMain",}});this._computeProjectivePipeline=this._device.createComputePipeline({label:"Ray Trace Volume Projective Pipeline "+this.getName(),layout:this._pipelineLayout,compute:{module:this._shaderModule,entryPoint:"computeProjectiveMain",}});}
createBindGroup(outTexture){this._bindGroup=this._device.createBindGroup({label:"Ray Trace Volume Bind Group",layout:this._computePipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this._cameraBuffer}},{binding:1,resource:{buffer:this._volumeBuffer}},{binding:2,resource:{buffer:this._dataBuffer}},{binding:3,resource:outTexture.createView()},{binding:4,resource:{buffer:this._modeBuffer}}],});this._wgWidth=Math.ceil(outTexture.width);this._wgHeight=Math.ceil(outTexture.height);}
compute(pass){if(this._camera?._isProjective){pass.setPipeline(this._computeProjectivePipeline);}
else{pass.setPipeline(this._computePipeline);}
pass.setBindGroup(0,this._bindGroup);pass.dispatchWorkgroups(Math.ceil(this._wgWidth/16),Math.ceil(this._wgHeight/16));}}
class PGA3D{static geometricProduct(a,b){return[a[0]*b[0]-a[1]*b[1]-a[2]*b[2]-a[3]*b[3]-a[7]*b[7]+a[11]*b[11]+a[12]*b[12]+a[13]*b[13],a[0]*b[1]+a[1]*b[0]-a[2]*b[3]+a[3]*b[2]+a[7]*b[13]+a[11]*b[12]-a[12]*b[11]+a[13]*b[7],a[0]*b[2]+a[1]*b[3]+a[2]*b[0]-a[3]*b[1]-a[7]*b[12]+a[11]*b[13]-a[12]*b[7]-a[13]*b[11],a[0]*b[3]-a[1]*b[2]+a[2]*b[1]+a[3]*b[0]+a[7]*b[11]+a[11]*b[7]+a[12]*b[13]-a[13]*b[12],a[0]*b[4]+a[1]*b[5]+a[2]*b[6]-a[3]*b[15]+a[4]*b[0]-a[5]*b[1]-a[6]*b[2]+a[7]*b[10]+a[8]*b[12]+a[9]*b[13]-a[10]*b[7]-a[11]*b[14]+a[12]*b[8]+a[13]*b[9]+a[14]*b[11]-a[15]*b[3],a[0]*b[5]-a[1]*b[4]+a[2]*b[15]+a[3]*b[6]+a[4]*b[1]+a[5]*b[0]-a[6]*b[3]-a[7]*b[9]-a[8]*b[11]+a[9]*b[7]+a[10]*b[12]-a[11]*b[8]-a[12]*b[14]+a[13]*b[10]+a[14]*b[12]+a[15]*b[2],a[0]*b[6]-a[1]*b[15]-a[2]*b[4]-a[3]*b[5]+a[4]*b[2]+a[5]*b[3]+a[6]*b[0]+a[7]*b[8]-a[8]*b[7]-a[9]*b[11]-a[10]*b[12]-a[11]*b[9]-a[12]*b[10]-a[13]*b[14]+a[14]*b[13]-a[15]*b[1],a[0]*b[7]+a[1]*b[13]-a[2]*b[12]+a[3]*b[11]+a[7]*b[0]+a[11]*b[3]-a[12]*b[2]+a[13]*b[1],a[0]*b[8]+a[1]*b[14]-a[2]*b[10]+a[3]*b[9]+a[4]*b[12]-a[5]*b[11]+a[6]*b[7]-a[7]*b[6]+a[8]*b[0]-a[9]*b[3]+a[10]*b[2]-a[11]*b[5]+a[12]*b[4]-a[13]*b[15]+a[14]*b[1]+a[15]*b[13],a[0]*b[9]+a[1]*b[10]+a[2]*b[14]-a[3]*b[8]+a[4]*b[13]-a[5]*b[7]-a[6]*b[11]+a[7]*b[5]+a[8]*b[3]+a[9]*b[0]-a[10]*b[1]-a[11]*b[6]+a[12]*b[15]+a[13]*b[4]+a[14]*b[2]-a[15]*b[12],a[0]*b[10]-a[1]*b[9]+a[2]*b[8]+a[3]*b[14]+a[4]*b[7]+a[5]*b[13]-a[6]*b[12]-a[7]*b[4]-a[8]*b[2]+a[9]*b[1]+a[10]*b[0]-a[11]*b[15]-a[12]*b[6]+a[13]*b[5]+a[14]*b[3]+a[15]*b[11],a[0]*b[11]+a[1]*b[12]+a[2]*b[13]-a[3]*b[7]-a[7]*b[3]+a[11]*b[0]-a[12]*b[1]-a[13]*b[2],a[0]*b[12]-a[1]*b[11]+a[2]*b[7]+a[3]*b[13]+a[7]*b[2]+a[11]*b[1]+a[12]*b[0]-a[13]*b[3],a[0]*b[13]-a[1]*b[7]-a[2]*b[11]-a[3]*b[12]-a[7]*b[1]+a[11]*b[2]+a[12]*b[3]+a[13]*b[0],a[0]*b[14]-a[1]*b[8]-a[2]*b[9]-a[3]*b[10]+a[4]*b[11]+a[5]*b[12]+a[6]*b[13]+a[7]*b[15]-a[8]*b[1]-a[9]*b[2]-a[10]*b[3]-a[11]*b[4]-a[12]*b[5]-a[13]*b[6]+a[14]*b[0]-a[15]*b[7],a[0]*b[15]+a[1]*b[6]-a[2]*b[5]+a[3]*b[4]+a[4]*b[3]-a[5]*b[2]+a[6]*b[1]-a[7]*b[14]+a[8]*b[13]-a[9]*b[12]+a[10]*b[11]-a[11]*b[10]+a[12]*b[9]-a[13]*b[8]+a[14]*b[7]+a[15]*b[0],];}
static reverse(a){return[a[0],-a[1],-a[2],-a[3],-a[4],-a[5],-a[6],-a[7],-a[8],-a[9],-a[10],a[11],a[12],a[13],a[14],a[15]];}
static applyMotor(p,m){return PGA3D.geometricProduct(m,PGA3D.geometricProduct(p,PGA3D.reverse(m)));}
static motorNorm(m){return Math.sqrt(m.map(val=>val*val).reduce((s,val)=>s+val,0));}
static createTranslator(dx,dy,dz){return[1,0,0,0,-dx/2,-dy/2,-dz/2,0,0,0,0,0,0,0,0,0];}
static extractTranslator(m){return[1,0,0,0,m[4],m[5],m[6],0,0,0,0,0,0,0,0,0];}
static createRotor(angle,dx=1,dy=0,dz=0,sx=0,sy=0,sz=0){let c=Math.cos(angle/2);let s=Math.sin(angle/2);let L=PGA3D.createLine(sx,sy,sz,dx,dy,dz);return[c,s*L[1],s*L[2],s*L[3],s*L[4],s*L[5],s*L[6],0,0,0,0,0,0,0,0,0];}
static extractRotor(m){return[m[0],m[1],m[2],m[3],0,0,0,0,0,0,0,0,0,0,0,0];}
static createDir(dx,dy,dz){return[0,dz,-dy,dx,0,0,0,0,0,0,0,0,0,0,0,0];}
static createLine(sx,sy,sz,dx,dy,dz){let n=PGA3D.createDir(dx,dy,dz);let dir=PGA3D.normalizeMotor(n);return[0,dir[1],dir[2],dir[3],-(-dir[2]*sz-dir[1]*sy),-(dir[1]*sx-dir[3]*sz),-(dir[3]*sy+dir[2]*sx),0,0,0,0,0,0,0,0,0];}
static createPoint(x,y,z){return[0,0,0,0,0,0,0,1,-z,y,-x,0,0,0,0,0];}
static extractPoint(p){return[-p[10]/p[7],p[9]/p[7],-p[8]/p[7]];}
static createPlane(nx,ny,nz,d){return[0,0,0,0,0,0,0,0,0,0,0,nx,ny,nz,-d,0];}
static createPlaneFromPoints(p1,p2,p3){let nx=(p2[1]*p3[2]-p3[1]*p2[2])-(p1[1]*p3[2]-p3[1]*p1[2])+(p1[1]*p2[2]-p2[1]*p1[2]);let ny=(p2[0]*p3[2]-p3[0]*p2[2])-(p1[0]*p3[2]-p3[0]*p1[2])+(p1[0]*p2[2]-p2[0]*p1[2]);let nz=(p2[0]*p3[1]-p3[0]*p2[1])-(p1[0]*p3[1]-p3[0]*p1[1])+(p1[0]*p2[1]-p2[0]*p1[1]);let d=(p1[0]*(p2[1]*p3[2]-p3[1]*p2[2])-p2[0]*(p1[1]*p3[2]-p3[1]*p1[2])+p3[0]*(p1[1]*p2[2]-p2[1]*p1[2]));return PGA3D.createPlane(nx,-ny,nz,d);}
static linePlaneIntersection(L,P){let new_p=PGA3D.geometricProduct(L,P);let isParallel=(Math.abs(new_p[7])<=0.00000001);let inPlane=isParallel&&(Math.abs(new_p[8])<=0.00000001)&&(Math.abs(new_p[9])<=0.00000001)&&(Math.abs(new_p[10])<=0.00000001);return[PGA3D.extractPoint(new_p),!isParallel,inPlane];}
static normalizeMotor(m){let mnorm=PGA3D.motorNorm(m);if(mnorm==0.0){return[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];}
return m.map(val=>val/mnorm);}
static applyMotorToPoint(p,m){let new_p=PGA3D.applyMotor(PGA3D.createPoint(p[0],p[1],p[2]),m);return PGA3D.extractPoint(new_p);};static applyMotorToDir(d,m){let r=PGA3D.extractRotor(m);let new_d=PGA3D.applyMotor(PGA3D.createPoint(d[0],d[1],d[2]),r);return PGA3D.extractPoint(new_d);}
static isInside(v0,v1,v2,p){let pga0=PGA3D.createPoint(v0[0],v0[1],v0[2]);let pga1=PGA3D.createPoint(v1[0],v1[1],v1[2]);let pga2=PGA3D.createPoint(v2[0],v2[1],v2[2]);let pgap=PGA3D.createPoint(p[0],p[1],p[2]);let plane012=PGA3D.createPlaneFromPoints(v0,v1,v2);let planep12=PGA3D.createPlaneFromPoints(p,v1,v2);let plane0p2=PGA3D.createPlaneFromPoints(v0,p,v2);let plane01p=PGA3D.createPlaneFromPoints(v0,v1,p);let area012=plane012[11]*plane012[11]+plane012[12]*plane012[12]+plane012[13]*plane012[13]+plane012[14]*plane012[14];let areap12=plane012[11]*planep12[11]+plane012[12]*planep12[12]+plane012[13]*planep12[13]+plane012[14]*planep12[14];let area0p2=plane012[11]*plane0p2[11]+plane012[12]*plane0p2[12]+plane012[13]*plane0p2[13]+plane012[14]*plane0p2[14];let area01p=plane012[11]*plane01p[11]+plane012[12]*plane01p[12]+plane012[13]*plane01p[13]+plane012[14]*plane01p[14];let lambda1=areap12/area012;let lambda2=area0p2/area012;let lambda3=area01p/area012;return lambda1>=0&&lambda1<=1&&lambda2>=0&&lambda2<=1&&lambda3>=0&&lambda3<=1;}}
class Camera{constructor(width,height){this._pose=new Float32Array(Array(16).fill(0));this._pose[0]=1;this._focal=new Float32Array(Array(2).fill(1));this._resolutions=new Float32Array([width,height]);this._isProjective=true;}
resetPose(){this._pose[0]=1;for(let i=1;i<16;++i)this._pose[i]=0;this._focal[0]=1;this._focal[1]=1;}
updatePose(newpose){for(let i=0;i<16;++i)this._pose[i]=newpose[i];}
updateSize(width,height){this._resolutions[0]=width;this._resolutions[1]=height;}
moveX(d){let newdir=PGA3D.applyMotorToDir([1,0,0],this._pose);let dt=PGA3D.createTranslator(newdir[0]*d,newdir[1]*d,newdir[2]*d);let newpose=PGA3D.geometricProduct(dt,this._pose);this.updatePose(newpose);}
moveY(d){let newdir=PGA3D.applyMotorToDir([0,1,0],this._pose);let dt=PGA3D.createTranslator(newdir[0]*d,newdir[1]*d,newdir[2]*d);let newpose=PGA3D.geometricProduct(dt,this._pose);this.updatePose(newpose);}
moveZ(d){let newdir=PGA3D.applyMotorToDir([0,0,1],this._pose);let dt=PGA3D.createTranslator(newdir[0]*d,newdir[1]*d,newdir[2]*d);let newpose=PGA3D.geometricProduct(dt,this._pose);this.updatePose(newpose);}
rotateX(d,a){let newdir=PGA3D.applyMotorToDir([1,0,0],this._pose);let newstartpt=PGA3D.applyMotorToPoint([0,0,0],this._pose);let dt=PGA3D.createRotor(a,newdir[0],newdir[1],newdir[2],newstartpt[0],newstartpt[1],newstartpt[2]);let newpose=PGA3D.geometricProduct(dt,this._pose);this.updatePose(newpose);}
rotateY(d,a){let newdir=PGA3D.applyMotorToDir([0,1,0],this._pose);let newstartpt=PGA3D.applyMotorToPoint([0,0,0],this._pose);let dt=PGA3D.createRotor(a,newdir[0],newdir[1],newdir[2],newstartpt[0],newstartpt[1],newstartpt[2]);let newpose=PGA3D.geometricProduct(dt,this._pose);this.updatePose(newpose);}
rotateZ(d,a){let newdir=PGA3D.applyMotorToDir([0,0,1],this._pose);let newstartpt=PGA3D.applyMotorToPoint([0,0,0],this._pose);let dt=PGA3D.createRotor(a,newdir[0],newdir[1],newdir[2],newstartpt[0],newstartpt[1],newstartpt[2]);let newpose=PGA3D.geometricProduct(dt,this._pose);this.updatePose(newpose);}};async function init(){const canvasTag=document.createElement('canvas');canvasTag.id="renderCanvas";document.body.appendChild(canvasTag);const tracer=new RayTracer(canvasTag);await tracer.init();var camera=new Camera();var tracerObj=new VolumeRenderingSimpleObject(tracer._device,tracer._canvasFormat,camera);await tracer.setTracerObject(tracerObj);var noise=new PerlinNoise();let fps='??';var fpsText=new StandardTextObject('fps: '+fps,"10");var instructions='move camera: wasdqe\nrotate camera: ijkluo\nv/V: change transfer function\nb/B: toggle visibility';var instructText=new StandardTextObject(instructions);var movespeed=0.05;var rotSpeed=0.1;var newFocal=new Float32Array(Array(2).fill(1));var needToWait=false;window.addEventListener("keydown",async(e)=>{switch(e.key){case'w':case'W':camera.moveY(-movespeed);tracerObj.updateCameraPose();break;case's':case'S':camera.moveY(movespeed);tracerObj.updateCameraPose();break;case'a':case'A':camera.moveX(-movespeed);tracerObj.updateCameraPose();break;case'd':case'D':camera.moveX(movespeed);tracerObj.updateCameraPose();break;case'e':case'E':camera.moveZ(movespeed);tracerObj.updateCameraPose();break;case'q':case'Q':camera.moveZ(-movespeed);tracerObj.updateCameraPose();break;case'k':case'K':camera.rotateX(movespeed,rotSpeed);tracerObj.updateCameraPose();break;case'i':case'I':camera.rotateX(-movespeed,-rotSpeed);tracerObj.updateCameraPose();break;case'l':case'L':camera.rotateY(movespeed,-rotSpeed);tracerObj.updateCameraPose();break;case'j':case'J':camera.rotateY(-movespeed,rotSpeed);tracerObj.updateCameraPose();break;case'u':case'U':camera.rotateZ(movespeed,rotSpeed);tracerObj.updateCameraPose();break;case'o':case'O':camera.rotateZ(-movespeed,-rotSpeed);tracerObj.updateCameraPose();break;case't':case'T':tracerObj.moveY(-movespeed);tracerObj.updateBoxPose();break;case'g':case'G':tracerObj.moveY(movespeed);tracerObj.updateBoxPose();break;case'f':case'F':tracerObj.moveX(-movespeed);tracerObj.updateBoxPose();break;case'h':case'H':tracerObj.moveX(movespeed);tracerObj.updateBoxPose();break;case'y':case'Y':tracerObj.moveZ(movespeed);tracerObj.updateBoxPose();break;case'r':case'R':tracerObj.moveZ(-movespeed);tracerObj.updateBoxPose();break;case'ArrowDown':tracerObj.rotateX(movespeed,rotSpeed);tracerObj.updateBoxPose();break;case'ArrowUp':tracerObj.rotateX(-movespeed,-rotSpeed);tracerObj.updateBoxPose();break;case'ArrowRight':tracerObj.rotateY(movespeed,-rotSpeed);tracerObj.updateBoxPose();break;case'ArrowLeft':tracerObj.rotateY(-movespeed,rotSpeed);tracerObj.updateBoxPose();break;case'n':case'N':tracerObj.rotateZ(movespeed,rotSpeed);tracerObj.updateBoxPose();break;case'm':case'M':tracerObj.rotateZ(-movespeed,-rotSpeed);tracerObj.updateBoxPose();break;case'[':newFocal[0]=tracerObj._camera._focal[0]+1;newFocal[1]=tracerObj._camera._focal[1];tracerObj.updateCameraFocal(newFocal);console.log(tracerObj._camera._focal);break;case']':newFocal[0]=tracerObj._camera._focal[0]-1;newFocal[1]=tracerObj._camera._focal[1];tracerObj.updateCameraFocal(newFocal);console.log(tracerObj._camera._focal);break;case'{':newFocal[0]=tracerObj._camera._focal[0];newFocal[1]=tracerObj._camera._focal[1]+1;tracerObj.updateCameraFocal(newFocal);console.log(tracerObj._camera._focal);break;case'}':newFocal[0]=tracerObj._camera._focal[0];newFocal[1]=tracerObj._camera._focal[1]-1;tracerObj.updateCameraFocal(newFocal);console.log(tracerObj._camera._focal);break;case'v':case'V':if(!needToWait){needToWait=true;const renderTypes=3;tracerObj._mode+=1;if(tracerObj._mode>renderTypes){tracerObj._mode=0;}
await tracerObj.updateMode();needToWait=false;}
break;case'b':case'B':fpsText.toggleVisibility();instructText.toggleVisibility();break;}});var frameCnt=0;var tgtFPS=60;var secPerFrame=1./tgtFPS;var frameInterval=secPerFrame*1000;var lastCalled;let renderFrame=()=>{let elapsed=Date.now()-lastCalled;if(elapsed>frameInterval){++frameCnt;lastCalled=Date.now()-(elapsed%frameInterval);tracer.render();}
requestAnimationFrame(renderFrame);};lastCalled=Date.now();renderFrame();setInterval(()=>{fpsText.updateText('fps: '+frameCnt);frameCnt=0;},1000);return tracer;}
init().then(ret=>{console.log(ret);}).catch(error=>{const pTag=document.createElement('p');pTag.innerHTML=navigator.userAgent+"</br>"+error.message;document.body.appendChild(pTag);document.getElementById("renderCanvas").remove();});