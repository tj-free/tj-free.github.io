class Renderer{constructor(canvas){this._canvas=canvas;this._objects=[];this._clearColor={r:0,g:56/255,b:101/255,a:1};}
async init(){if(!navigator.gpu){throw Error("WebGPU is not supported in this browser.");}
const adapter=await navigator.gpu.requestAdapter();if(!adapter){throw Error("Couldn't request WebGPU adapter.");}
this._device=await adapter.requestDevice();this._context=this._canvas.getContext("webgpu");this._canvasFormat=navigator.gpu.getPreferredCanvasFormat();this._context.configure({device:this._device,format:this._canvasFormat,});this.resizeCanvas();window.addEventListener('resize',this.resizeCanvas.bind(this));}
resizeCanvas(){const devicePixelRatio=window.devicePixelRatio||1;const width=window.innerWidth*devicePixelRatio;const height=window.innerHeight*devicePixelRatio;this._canvas.width=width;this._canvas.height=height;this._canvas.style.width=`${window.innerWidth}px`;this._canvas.style.height=`${window.innerHeight}px`;this._canvas.style.transformOrigin="center";this.render();}
async appendSceneObject(obj){await obj.init();this._objects.push(obj);}
renderToSelectedView(outputView){for(const obj of this._objects){obj?.updateGeometry();}
let encoder=this._device.createCommandEncoder();const pass=encoder.beginRenderPass({colorAttachments:[{view:outputView,clearValue:this._clearColor,loadOp:"clear",storeOp:"store",}]});for(const obj of this._objects){obj?.render(pass);}
pass.end();const computePass=encoder.beginComputePass();for(const obj of this._objects){obj?.compute(computePass);}
computePass.end();const commandBuffer=encoder.finish();this._device.queue.submit([commandBuffer]);}
render(){this.renderToSelectedView(this._context.getCurrentTexture().createView());}}
class SceneObject{static _objectCnt=0;constructor(device,canvasFormat){if(this.constructor==SceneObject){throw new Error("Abstract classes can't be instantiated.");}
this._device=device;this._canvasFormat=canvasFormat;SceneObject._objectCnt+=1;}
getName(){return this.constructor.name+" "+SceneObject._objectCnt.toString();}
async init(){await this.createGeometry();await this.createShaders();await this.createRenderPipeline();await this.createComputePipeline();}
async createGeometry(){throw new Error("Method 'createGeometry()' must be implemented.");}
updateGeometry(){}
loadShader(filename){return new Promise((resolve,reject)=>{const xhttp=new XMLHttpRequest();xhttp.open("GET",filename);xhttp.setRequestHeader("Cache-Control","no-cache, no-store, max-age=0");xhttp.onload=function(){if(xhttp.readyState===XMLHttpRequest.DONE&&xhttp.status===200){resolve(xhttp.responseText);}
else{reject({status:xhttp.status,statusText:xhttp.statusText});}};xhttp.onerror=function(){reject({status:xhttp.status,statusText:xhttp.statusText});};xhttp.send();});}
async createShaders(){throw new Error("Method 'createShaders()' must be implemented.");}
async createRenderPipeline(){throw new Error("Method 'createRenderPipeline()' must be implemented.");}
render(pass){throw new Error("Method 'render(pass)' must be implemented.");}
async createComputePipeline(){throw new Error("Method 'createComputePipeline()' must be implemented.");}
compute(pass){throw new Error("Method 'compute(pass)' must be implemented.");}}
class ParticleSystemObject extends SceneObject{constructor(device,canvasFormat,canvasTag,numParticles=51200){super(device,canvasFormat);this._numParticles=numParticles;this._step=0;this._canvasTag=canvasTag;}
async createGeometry(){await this.createParticleGeometry();}
async createParticleGeometry(){this._timeBuffer=this._device.createBuffer({label:"Time",size:4,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,});const time=performance.now()/1000;this._device.queue.writeBuffer(this._timeBuffer,0,new Float32Array([time]));this._mouseBuffer=this._device.createBuffer({label:"Mouse",size:8,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,});this._canvasTag.addEventListener('mousemove',(e)=>{var mouseX=(e.clientX/window.innerWidth)*2-1;var mouseY=(-e.clientY/window.innerHeight)*2+1;const mouse=new Float32Array([mouseX,mouseY]);this._device.queue.writeBuffer(this._mouseBuffer,0,mouse);});this._particles=new Float32Array(this._numParticles*16);this._particleBuffers=[this._device.createBuffer({label:"Grid status Buffer 1 "+this.getName(),size:this._particles.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,}),this._device.createBuffer({label:"Grid status Buffer 2 "+this.getName(),size:this._particles.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,})];this.resetParticles();}
resetParticles(){const prtSpd=0.01;const lifespan=255;const vars=16;for(let i=0;i<this._numParticles;++i){this._particles[vars*i+0]=(Math.random()*0.5);this._particles[vars*i+1]=0.75;this._particles[vars*i+2]=this._particles[10*i+0];this._particles[vars*i+3]=this._particles[10*i+1];let random=Math.floor(Math.random()*(1-0.5+1))+1;this._particles[vars*i+4]=(0.75)*0.001;this._particles[vars*i+5]=(Math.random()*-prtSpd);this._particles[vars*i+6]=this._particles[10*i+4];this._particles[vars*i+7]=this._particles[10*i+5];this._particles[vars*i+8]=(Math.random()*(lifespan/2)+lifespan/2);this._particles[vars*i+9]=lifespan;this._particles[vars*i+10]=0;this._particles[vars*i+11]=0;this._particles[vars*i+12]=0;this._particles[vars*i+13]=0;this._particles[vars*i+14]=0;this._particles[vars*i+15]=0;}
this._step=0;this._device.queue.writeBuffer(this._particleBuffers[this._step%2],0,this._particles);}
updateGeometry(){}
async createShaders(){let shaderCode=await this.loadShader("/shaders/optimized_particles.wgsl");this._shaderModule=this._device.createShaderModule({label:"Particles Shader "+this.getName(),code:shaderCode,});this._bindGroupLayout=this._device.createBindGroupLayout({label:"Grid Bind Group Layout "+this.getName(),entries:[{binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}}]});this._pipelineLayout=this._device.createPipelineLayout({label:"Particles Pipeline Layout",bindGroupLayouts:[this._bindGroupLayout],});}
async createRenderPipeline(){await this.createParticlePipeline();}
async createParticlePipeline(){this._particlePipeline=this._device.createRenderPipeline({label:"Particles Render Pipeline "+this.getName(),layout:this._pipelineLayout,vertex:{module:this._shaderModule,entryPoint:"vertexMain",},fragment:{module:this._shaderModule,entryPoint:"fragmentMain",targets:[{format:this._canvasFormat,blend:{color:{srcFactor:'one',dstFactor:'one-minus-src-alpha',operator:'add',},alpha:{srcFactor:'one',dstFactor:'one-minus-src-alpha',operator:'add',},},}]}});this._bindGroups=[this._device.createBindGroup({layout:this._particlePipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this._particleBuffers[0]}},{binding:1,resource:{buffer:this._particleBuffers[1]}},{binding:2,resource:{buffer:this._timeBuffer}},{binding:3,resource:{buffer:this._mouseBuffer}}],}),this._device.createBindGroup({layout:this._particlePipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this._particleBuffers[1]}},{binding:1,resource:{buffer:this._particleBuffers[0]}},{binding:2,resource:{buffer:this._timeBuffer}},{binding:3,resource:{buffer:this._mouseBuffer}}],})];}
render(pass){pass.setPipeline(this._particlePipeline);pass.setBindGroup(0,this._bindGroups[this._step%2]);pass.draw(128,this._numParticles);}
async createComputePipeline(){this._computePipeline=this._device.createComputePipeline({label:"Particles Compute Pipeline "+this.getName(),layout:this._pipelineLayout,compute:{module:this._shaderModule,entryPoint:"computeMain",}});}
compute(pass){pass.setPipeline(this._computePipeline);pass.setBindGroup(0,this._bindGroups[this._step%2]);pass.dispatchWorkgroups(Math.ceil(this._numParticles/256));++this._step
const time=performance.now()/1000;this._device.queue.writeBuffer(this._timeBuffer,0,new Float32Array([time]));}}
class StandardTextObject{constructor(inputText,spacing=5,textFont='18px Arial'){this._textFont=textFont;this._lineSpacing=spacing;this._textCanvas=document.createElement('canvas');this._textContext=this._textCanvas.getContext('2d');this.updateTextRegion(inputText);this.updateText(inputText);this._textCanvas.style.position='absolute';this._textCanvas.style.top='10px';this._textCanvas.style.left='10px';this._textCanvas.style.border='1px solid red';document.body.appendChild(this._textCanvas);}
toggleVisibility(){this._textCanvas.hidden=!this._textCanvas.hidden;}
updateTextRegion(newText){this._textContext.font=this._textFont;this._lines=newText.split('\n');this._width=Math.max(...this._lines.map(line=>this._textContext.measureText(line).width));const match=this._textFont.match(/(\d+)px/);if(match){this._fontSize=parseInt(match[1],10);}
else{this._fontSize=18;this._textFont="18px Arial";}
this._height=this._lines.length*(this._fontSize+this._lineSpacing);this._paddingx=5;this._paddingtop=3;this._canvasWidth=Math.ceil(this._width+this._paddingx*2);this._canvasHeight=Math.ceil(this._height+this._paddingtop);this._textCanvas.width=this._canvasWidth;this._textCanvas.height=this._canvasHeight;this._textContext.font=this._textFont;this._textContext.textBaseline='top';}
updateText(newText){this._lines=newText.split('\n');this._textContext.fillStyle='rgba(1, 1, 1, 0.5)';this._textContext.clearRect(0,0,this._canvasWidth,this._canvasHeight);this._textContext.fillRect(0,0,this._canvasWidth,this._canvasHeight);this._textContext.fillStyle='white';this._lines.forEach((line,idx)=>{const x=this._paddingx;const y=this._paddingtop+idx*(this._fontSize+this._lineSpacing);this._textContext.fillText(line,x,y);});}}
async function init(){const canvasTag=document.createElement('canvas');canvasTag.id="renderCanvas";document.body.appendChild(canvasTag);const renderer=new Renderer(canvasTag);await renderer.init();const particles=new ParticleSystemObject(renderer._device,renderer._canvasFormat,renderer._canvas);await renderer.appendSceneObject(particles);let fps='??';var fpsText=new StandardTextObject('fps: '+fps);var frameCnt=0;var tgtFPS=60;var secPerFrame=1./tgtFPS;var frameInterval=secPerFrame*1000;var lastCalled;let renderFrame=()=>{let elapsed=Date.now()-lastCalled;if(elapsed>frameInterval){++frameCnt;lastCalled=Date.now()-(elapsed%frameInterval);renderer.render();}
requestAnimationFrame(renderFrame);};lastCalled=Date.now();renderFrame();setInterval(()=>{fpsText.updateText('fps: '+frameCnt);frameCnt=0;},1000);return renderer;}
init().then(ret=>{console.log(ret);}).catch(error=>{const pTag=document.createElement('p');pTag.innerHTML=navigator.userAgent+"</br>"+error.message;document.body.appendChild(pTag);document.getElementById("renderCanvas").remove();});