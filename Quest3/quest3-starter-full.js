class Renderer{constructor(canvas){this._canvas=canvas;this._objects=[];this._clearColor={r:0,g:56/255,b:101/255,a:1};}
async init(){if(!navigator.gpu){throw Error("WebGPU is not supported in this browser.");}
const adapter=await navigator.gpu.requestAdapter();if(!adapter){throw Error("Couldn't request WebGPU adapter.");}
this._device=await adapter.requestDevice();this._context=this._canvas.getContext("webgpu");this._canvasFormat=navigator.gpu.getPreferredCanvasFormat();this._context.configure({device:this._device,format:this._canvasFormat,});this.resizeCanvas();window.addEventListener('resize',this.resizeCanvas.bind(this));}
resizeCanvas(){const devicePixelRatio=window.devicePixelRatio||1;const width=window.innerWidth*devicePixelRatio;const height=window.innerHeight*devicePixelRatio;this._canvas.width=width;this._canvas.height=height;this._canvas.style.width=`${window.innerWidth}px`;this._canvas.style.height=`${window.innerHeight}px`;this._canvas.style.transformOrigin="center";this.render();}
async appendSceneObject(obj){await obj.init();this._objects.push(obj);}
renderToSelectedView(outputView){for(const obj of this._objects){obj?.updateGeometry();}
let encoder=this._device.createCommandEncoder();const pass=encoder.beginRenderPass({colorAttachments:[{view:outputView,clearValue:this._clearColor,loadOp:"clear",storeOp:"store",}]});for(const obj of this._objects){obj?.render(pass);}
pass.end();const computePass=encoder.beginComputePass();for(const obj of this._objects){obj?.compute(computePass);}
computePass.end();const commandBuffer=encoder.finish();this._device.queue.submit([commandBuffer]);}
render(){this.renderToSelectedView(this._context.getCurrentTexture().createView());}}
class PGA2D{static geometricProduct(a,b){return[a[0]*b[0]-a[1]*b[1],a[0]*b[1]+a[1]*b[0],a[0]*b[2]+a[1]*b[3]+a[2]*b[0]-a[3]*b[1],a[0]*b[3]-a[1]*b[2]+a[2]*b[1]+a[3]*b[0]];}
static reverse(a){return[a[0],-a[1],-a[2],-a[3]];}
static applyMotor(p,m){return PGA2D.geometricProduct(m,PGA2D.geometricProduct(p,PGA2D.reverse(m)));}
static motorNorm(m){return Math.sqrt(m[0]*m[0]+m[1]*m[1]+m[2]*m[2]+m[3]*m[3]);}
static createTranslator(dx,dy){return[1,0,dy/2,-dx/2]}
static createRotor(angle,cx=0,cy=0){return[Math.cos(angle/2),-Math.sin(angle/2),-cx*Math.sin(angle/2),-cy*Math.sin(angle/2)];}
static normaliozeMotor(m){let mnorm=PGA2D.motorNorm(m);if(mnorm==0.0){return[1,0,0,0];}
return[m[0]/mnorm,m[1]/mnorm,m[2]/mnorm,m[3]/mnorm];}
static applyMotorToPoint(p,m){let new_p=PGA2D.applyMotor([0,1,p[0],p[1]],m);return[new_p[2]/new_p[1],new_p[3]/new_p[1]];};}
class Camera{constructor(){this._pose=new Float32Array([1,0,0,0,1,1]);}
resetPose(){this._pose[0]=1;this._pose[1]=0;this._pose[2]=0;this._pose[3]=0;this._pose[4]=1;this._pose[5]=1;}
updatePose(newpose){this._pose[0]=newpose[0];this._pose[1]=newpose[1];this._pose[2]=newpose[2];this._pose[3]=newpose[3];}
moveLeft(d){let dt=PGA2D.createTranslator(-d,0);let newpose=PGA2D.normaliozeMotor(PGA2D.geometricProduct(dt,[this._pose[0],this._pose[1],this._pose[2],this._pose[3]]));this.updatePose(newpose);}
moveRight(d){let dt=PGA2D.createTranslator(d,0);let newpose=PGA2D.normaliozeMotor(PGA2D.geometricProduct(dt,[this._pose[0],this._pose[1],this._pose[2],this._pose[3]]));this.updatePose(newpose);}
moveUp(d){let dt=PGA2D.createTranslator(0,d);let newpose=PGA2D.normaliozeMotor(PGA2D.geometricProduct(dt,[this._pose[0],this._pose[1],this._pose[2],this._pose[3]]));this.updatePose(newpose);}
moveDown(d){let dt=PGA2D.createTranslator(0,-d);let newpose=PGA2D.normaliozeMotor(PGA2D.geometricProduct(dt,[this._pose[0],this._pose[1],this._pose[2],this._pose[3]]));this.updatePose(newpose);}
zoomIn(){this._pose[4]*=1.1;this._pose[5]*=1.1;}
zoomOut(){this._pose[4]/=1.1;this._pose[5]/=1.1;}}
class SceneObject{static _objectCnt=0;constructor(device,canvasFormat){if(this.constructor==SceneObject){throw new Error("Abstract classes can't be instantiated.");}
this._device=device;this._canvasFormat=canvasFormat;SceneObject._objectCnt+=1;}
getName(){return this.constructor.name+" "+SceneObject._objectCnt.toString();}
async init(){await this.createGeometry();await this.createShaders();await this.createRenderPipeline();await this.createComputePipeline();}
async createGeometry(){throw new Error("Method 'createGeometry()' must be implemented.");}
updateGeometry(){}
loadShader(filename){return new Promise((resolve,reject)=>{const xhttp=new XMLHttpRequest();xhttp.open("GET",filename);xhttp.setRequestHeader("Cache-Control","no-cache, no-store, max-age=0");xhttp.onload=function(){if(xhttp.readyState===XMLHttpRequest.DONE&&xhttp.status===200){resolve(xhttp.responseText);}
else{reject({status:xhttp.status,statusText:xhttp.statusText});}};xhttp.onerror=function(){reject({status:xhttp.status,statusText:xhttp.statusText});};xhttp.send();});}
async createShaders(){throw new Error("Method 'createShaders()' must be implemented.");}
async createRenderPipeline(){throw new Error("Method 'createRenderPipeline()' must be implemented.");}
render(pass){throw new Error("Method 'render(pass)' must be implemented.");}
async createComputePipeline(){throw new Error("Method 'createComputePipeline()' must be implemented.");}
compute(pass){throw new Error("Method 'compute(pass)' must be implemented.");}}
class CameraLineStrip2DAliveDeadObject extends SceneObject{constructor(device,canvasFormat,cameraPose,vertices){super(device,canvasFormat);this._cameraPose=cameraPose;if(typeof this._vertices===Float32Array)this._vertices=vertices;else this._vertices=new Float32Array(vertices);this.gridSize=1000;}
async createGeometry(){this._vertexBuffer=this._device.createBuffer({label:"Vertices "+this.getName(),size:this._vertices.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST,});this._device.queue.writeBuffer(this._vertexBuffer,0,this._vertices);this._vertexBufferLayout={arrayStride:2*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:0,format:"float32x2",offset:0,}],};this._cameraPoseBuffer=this._device.createBuffer({label:"Camera Pose "+this.getName(),size:this._cameraPose.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,});this._device.queue.writeBuffer(this._cameraPoseBuffer,0,this._cameraPose);this._cellStatus=new Uint32Array(this.gridSize*this.gridSize);this._cellStateBuffers=[this._device.createBuffer({label:"Grid status Buffer 1 "+this.getName(),size:this._cellStatus.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,}),this._device.createBuffer({label:"Grid status Buffer 2 "+this.getName(),size:this._cellStatus.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,})];this._device.queue.writeBuffer(this._cellStateBuffers[0],0,this._cellStatus);this._step=0;}
updateCameraPose(){this._device.queue.writeBuffer(this._cameraPoseBuffer,0,this._cameraPose);}
async createShaders(){let shaderCode=await this.loadShader("/shaders/optimized_camera2dalivedead.wgsl");this._shaderModule=this._device.createShaderModule({label:" Shader "+this.getName(),code:shaderCode,});this._bindGroupLayout=this._device.createBindGroupLayout({label:"Grid Bind Group Layout "+this.getName(),entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{}},{binding:1,visibility:GPUShaderStage.VERTEX|GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]});this._pipelineLayout=this._device.createPipelineLayout({label:"Grid Pipeline Layout",bindGroupLayouts:[this._bindGroupLayout],});}
async createRenderPipeline(){this._renderPipeline=this._device.createRenderPipeline({label:"Render Pipeline "+this.getName(),layout:this._pipelineLayout,vertex:{module:this._shaderModule,entryPoint:"vertexMain",buffers:[this._vertexBufferLayout]},fragment:{module:this._shaderModule,entryPoint:"fragmentMain",targets:[{format:this._canvasFormat}]},primitive:{topology:'line-strip'}});this._bindGroups=[this._device.createBindGroup({label:"Renderer Bind Group 1 "+this.getName(),layout:this._renderPipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this._cameraPoseBuffer}},{binding:1,resource:{buffer:this._cellStateBuffers[0]}},{binding:2,resource:{buffer:this._cellStateBuffers[1]}}],}),this._device.createBindGroup({label:"Renderer Bind Group 2 "+this.getName(),layout:this._renderPipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this._cameraPoseBuffer}},{binding:1,resource:{buffer:this._cellStateBuffers[1]}},{binding:2,resource:{buffer:this._cellStateBuffers[0]}}],})];}
render(pass){pass.setPipeline(this._renderPipeline);pass.setVertexBuffer(0,this._vertexBuffer);pass.setBindGroup(0,this._bindGroups[this._step%2]);pass.draw(this._vertices.length/2,this.gridSize*this.gridSize);}
async createComputePipeline(){this._computePipeline=this._device.createComputePipeline({label:"Grid update pipeline "+this.getName(),layout:this._pipelineLayout,compute:{module:this._shaderModule,entryPoint:"computeMain",}});}
compute(pass){pass.setPipeline(this._computePipeline);pass.setBindGroup(0,this._bindGroups[this._step%2]);pass.dispatchWorkgroups(Math.ceil(this.gridSize/4),Math.ceil(this.gridSize/4));++this._step;}}
class StandardTextObject{constructor(inputText,right='',left='10',top='10',spacing=5,textFont='18px Arial'){this._textFont=textFont;this._lineSpacing=spacing;this._textCanvas=document.createElement('canvas');this._textContext=this._textCanvas.getContext('2d');this.updateTextRegion(inputText);this.updateText(inputText);this._textCanvas.style.position='absolute';if(right!=''){this._textCanvas.style.right=right+'px';}else{this._textCanvas.style.left=left+'px';}
this._textCanvas.style.top=top+'px';this._textCanvas.style.border='1px solid red';document.body.appendChild(this._textCanvas);}
toggleVisibility(){this._textCanvas.hidden=!this._textCanvas.hidden;}
updateTextRegion(newText){this._textContext.font=this._textFont;this._lines=newText.split('\n');this._width=Math.max(...this._lines.map(line=>this._textContext.measureText(line).width));const match=this._textFont.match(/(\d+)px/);if(match){this._fontSize=parseInt(match[1],10);}
else{this._fontSize=18;this._textFont="18px Arial";}
this._height=this._lines.length*(this._fontSize+this._lineSpacing);this._paddingx=5;this._paddingtop=3;this._canvasWidth=Math.ceil(this._width+this._paddingx*2);this._canvasHeight=Math.ceil(this._height+this._paddingtop);this._textCanvas.width=this._canvasWidth;this._textCanvas.height=this._canvasHeight;this._textContext.font=this._textFont;this._textContext.textBaseline='top';}
updateText(newText){this._lines=newText.split('\n');this._textContext.fillStyle='rgba(1, 1, 1, 0.5)';this._textContext.clearRect(0,0,this._canvasWidth,this._canvasHeight);this._textContext.fillRect(0,0,this._canvasWidth,this._canvasHeight);this._textContext.fillStyle='white';this._lines.forEach((line,idx)=>{const x=this._paddingx;const y=this._paddingtop+idx*(this._fontSize+this._lineSpacing);this._textContext.fillText(line,x,y);});}}
class Standard2DPGACameraSceneObject extends SceneObject{constructor(device,canvasFormat,cameraPose,vertices,pose){super(device,canvasFormat);this._vertices=vertices;this._pose=pose;this._cameraPose=cameraPose;}
async createGeometry(){this._vertexBuffer=this._device.createBuffer({label:"Vertices "+this.getName(),size:this._vertices.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST,});this._device.queue.writeBuffer(this._vertexBuffer,0,this._vertices);this._vertexBufferLayout={arrayStride:6*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:0,format:"float32x2",offset:0,},{shaderLocation:1,format:"float32x4",offset:2*Float32Array.BYTES_PER_ELEMENT,}],};this._poseBuffer=this._device.createBuffer({label:"Pose "+this.getName(),size:this._pose.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,});this._device.queue.writeBuffer(this._poseBuffer,0,this._pose);this._cameraPoseBuffer=this._device.createBuffer({label:"Camera Pose "+this.getName(),size:this._cameraPose.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,});this._device.queue.writeBuffer(this._cameraPoseBuffer,0,this._cameraPose);}
updateGeometry(){this._device.queue.writeBuffer(this._poseBuffer,0,this._pose);}
updateCameraPose(){this._device.queue.writeBuffer(this._cameraPoseBuffer,0,this._cameraPose);}
async createShaders(){let shaderCode=await this.loadShader("/shaders/optimized_standard2dpgacamera.wgsl");this._shaderModule=this._device.createShaderModule({label:" Shader "+this.getName(),code:shaderCode,});}
async createRenderPipeline(){this._renderPipeline=this._device.createRenderPipeline({label:"Render Pipeline "+this.getName(),layout:"auto",vertex:{module:this._shaderModule,entryPoint:"vertexMain",buffers:[this._vertexBufferLayout]},fragment:{module:this._shaderModule,entryPoint:"fragmentMain",targets:[{format:this._canvasFormat}]}});this._bindGroup=this._device.createBindGroup({label:"Render Bind Group "+this.getName(),layout:this._renderPipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this._poseBuffer},},{binding:1,resource:{buffer:this._cameraPoseBuffer}}],});}
render(pass){pass.setPipeline(this._renderPipeline);pass.setVertexBuffer(0,this._vertexBuffer);pass.setBindGroup(0,this._bindGroup);pass.draw(this._vertices.length/6);}
async createComputePipeline(){}
compute(pass){}}
async function init(){const canvasTag=document.createElement('canvas');canvasTag.id="renderCanvas";document.body.appendChild(canvasTag);const renderer=new Renderer(canvasTag);await renderer.init();var vertices=new Float32Array([-0.5,-0.5,0.5,-0.5,0.5,0.5,-0.5,0.5,-0.5,-0.5]);const camera=new Camera();const grid=new CameraLineStrip2DAliveDeadObject(renderer._device,renderer._canvasFormat,camera._pose,vertices);await renderer.appendSceneObject(grid);var pose=new Float32Array([1,0,0,0,0.025,0.025]);var quadVertices=new Float32Array([-1,-1,1,0,0,1,1,-1,0,1,0,1,-1,1,0,0,1,1,1,1,1,0,1,1,-1,1,0,0,1,1,1,-1,0,1,0,1]);const quad=new Standard2DPGACameraSceneObject(renderer._device,renderer._canvasFormat,camera._pose,quadVertices,pose);await renderer.appendSceneObject(quad);let fps='??';var fpsText=new StandardTextObject('fps: '+fps,"10");var instructText=new StandardTextObject('up/w/W: move up\nleft/a/A: mode left\ndown/s/S: move down\nright/d/D: move right\nq/Q: zoom in\ne/E: zoom out\nf/F: toggle visibility\nleft click: drag');var movespeed=0.05;window.addEventListener("keydown",(e)=>{switch(e.key){case'ArrowUp':case'w':case'W':camera.moveUp(movespeed);grid.updateCameraPose();quad.updateCameraPose();break;case'ArrowDown':case's':case'S':camera.moveDown(movespeed);grid.updateCameraPose();quad.updateCameraPose();break;case'ArrowLeft':case'a':case'A':camera.moveLeft(movespeed);grid.updateCameraPose();quad.updateCameraPose();break;case'ArrowRight':case'd':case'D':camera.moveRight(movespeed);grid.updateCameraPose();quad.updateCameraPose();break;case'q':case'Q':camera.zoomIn();grid.updateCameraPose();quad.updateCameraPose();break;case'e':case'E':camera.zoomOut();grid.updateCameraPose();quad.updateCameraPose();break;case'f':case'F':fpsText.toggleVisibility();instructText.toggleVisibility();break;}});let isDragging=false;let oldP=[0,0];canvasTag.addEventListener('mousedown',(e)=>{var mouseX=(e.clientX/window.innerWidth)*2-1;var mouseY=(-e.clientY/window.innerHeight)*2+1;mouseX/=camera._pose[4];mouseY/=camera._pose[5];let p=PGA2D.applyMotorToPoint([mouseX,mouseY],[camera._pose[0],camera._pose[1],camera._pose[2],camera._pose[3]]);oldP=[...p];p[0]/=pose[4];p[1]/=pose[5];let sp=PGA2D.applyMotorToPoint(p,PGA2D.reverse([pose[0],pose[1],pose[2],pose[3]]));if(-1<=sp[0]&&sp[0]<=1&&-1<=sp[1]&&sp[1]<=1){isDragging=true;}});canvasTag.addEventListener('mousemove',(e)=>{let gridSize=1000;var mouseX=(e.clientX/window.innerWidth)*2-1;var mouseY=(-e.clientY/window.innerHeight)*2+1;mouseX/=camera._pose[4];mouseY/=camera._pose[5];let p=PGA2D.applyMotorToPoint([mouseX,mouseY],[camera._pose[0],camera._pose[1],camera._pose[2],camera._pose[3]]);let halfLength=1;let cellLength=halfLength*2;let u=Math.floor((p[0]+halfLength)/cellLength*10);let v=Math.floor((p[1]+halfLength)/cellLength*10);if(u>=0&&u<gridSize&&v>=0&&v<10){let offsetX=-halfLength+u/gridSize*cellLength+cellLength/gridSize*0.5;let offsetY=-halfLength+v/gridSize*cellLength+cellLength/gridSize*0.5;if(-0.5/gridSize+offsetX<=p[0]&&p[0]<=0.5/gridSize+offsetX&&-0.5/gridSize+offsetY<=p[1]&&p[1]<=0.5/gridSize+offsetY){console.log(`in cell (${u}, ${v})`);}}
if(isDragging){let diff=Math.sqrt(Math.pow(p[0]-oldP[0],2)+Math.pow(p[1]-oldP[1],2));if(diff>0.001){let dt=PGA2D.createTranslator((p[0]-oldP[0])/pose[4],(p[1]-oldP[1])/pose[5]);let newmotor=PGA2D.normaliozeMotor(PGA2D.geometricProduct(dt,[pose[0],pose[1],pose[2],pose[3]]));pose[0]=newmotor[0];pose[1]=newmotor[1];pose[2]=newmotor[2];pose[3]=newmotor[3];quad.updateGeometry();oldP=p;}}});canvasTag.addEventListener('mouseup',(e)=>{isDragging=false;});var frameCnt=0;var tgtFPS=60;var secPerFrame=1./tgtFPS;var frameInterval=secPerFrame*1000;var lastCalled;let renderFrame=()=>{let elapsed=Date.now()-lastCalled;if(elapsed>frameInterval){++frameCnt;lastCalled=Date.now()-(elapsed%frameInterval);renderer.render();}
requestAnimationFrame(renderFrame);};lastCalled=Date.now();renderFrame();setInterval(()=>{fpsText.updateText('fps: '+frameCnt);frameCnt=0;},1000);return renderer;}
init().then(ret=>{console.log(ret);}).catch(error=>{const pTag=document.createElement('p');pTag.innerHTML=navigator.userAgent+"</br>"+error.message;document.body.appendChild(pTag);document.getElementById("renderCanvas").remove();});