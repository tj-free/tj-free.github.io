class Renderer{constructor(canvas){this._canvas=canvas;this._objects=[];this._clearColor={r:0,g:56/255,b:101/255,a:1};}
async init(){if(!navigator.gpu){throw Error("WebGPU is not supported in this browser.");}
const adapter=await navigator.gpu.requestAdapter();if(!adapter){throw Error("Couldn't request WebGPU adapter.");}
this._device=await adapter.requestDevice();this._context=this._canvas.getContext("webgpu");this._canvasFormat=navigator.gpu.getPreferredCanvasFormat();this._context.configure({device:this._device,format:this._canvasFormat,});this.resizeCanvas();window.addEventListener('resize',this.resizeCanvas.bind(this));}
resizeCanvas(){const devicePixelRatio=window.devicePixelRatio||1;const width=window.innerWidth*devicePixelRatio;const height=window.innerHeight*devicePixelRatio;this._canvas.width=width;this._canvas.height=height;this._canvas.style.width=`${window.innerWidth}px`;this._canvas.style.height=`${window.innerHeight}px`;this._canvas.style.transformOrigin="center";this.render();}
async appendSceneObject(obj){await obj.init();this._objects.push(obj);}
renderToSelectedView(outputView){for(const obj of this._objects){obj?.updateGeometry();}
let encoder=this._device.createCommandEncoder();const pass=encoder.beginRenderPass({colorAttachments:[{view:outputView,clearValue:this._clearColor,loadOp:"clear",storeOp:"store",}]});for(const obj of this._objects){obj?.render(pass);}
pass.end();const computePass=encoder.beginComputePass();for(const obj of this._objects){obj?.compute(computePass);}
computePass.end();const commandBuffer=encoder.finish();this._device.queue.submit([commandBuffer]);}
render(){this.renderToSelectedView(this._context.getCurrentTexture().createView());}}
class FilteredRenderer extends Renderer{constructor(canvas){super(canvas);this._filters=[];}
async init(){if(!navigator.gpu){throw Error("WebGPU is not supported in this browser.");}
const adapter=await navigator.gpu.requestAdapter();if(!adapter){throw Error("Couldn't request WebGPU adapter.");}
this._device=await adapter.requestDevice();this._context=this._canvas.getContext("webgpu");this._canvasFormat="rgba8unorm";this._context.configure({device:this._device,format:this._canvasFormat,});this._shaderModule=this._device.createShaderModule({label:"Image Filter Renderer Shader",code:`
      @vertex
      fn vertexMain(@builtin(vertex_index) vIdx: u32) -> @builtin(position) vec4f {
        var pos = array<vec2f, 6>(
          vec2f(-1, -1), vec2f(1, -1), vec2f(-1, 1),
          vec2f(-1, 1), vec2f(1, -1), vec2f(1, 1)
        );
        return vec4f(pos[vIdx], 0, 1);
      }
      
      @group(0) @binding(0) var inTexture: texture_2d<f32>;
      @group(0) @binding(1) var inSampler: sampler;
      
      @fragment
      fn fragmentMain(@builtin(position) fragCoord: vec4f) -> @location(0) vec4f {
        let uv = fragCoord.xy / vec2f(textureDimensions(inTexture, 0));
        return textureSample(inTexture, inSampler, uv);
      }
      `});this._pipeline=this._device.createRenderPipeline({label:"Image Filter Renderer Pipeline",layout:"auto",vertex:{module:this._shaderModule,entryPoint:"vertexMain",},fragment:{module:this._shaderModule,entryPoint:"fragmentMain",targets:[{format:this._canvasFormat}]}});this._sampler=this._device.createSampler({label:"Image Filter Renderer Sampler",magFilter:"linear",minFilter:"linear"});this.resizeCanvas();window.addEventListener('resize',this.resizeCanvas.bind(this));}
resizeCanvas(){const devicePixelRatio=window.devicePixelRatio||1;const width=window.innerWidth*devicePixelRatio;const height=window.innerHeight*devicePixelRatio;let imgSize={width:width,height:height};this._textures=[];this._textures.push(this._device.createTexture({size:imgSize,format:this._canvasFormat,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING,}),this._device.createTexture({size:imgSize,format:this._canvasFormat,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING,}),);for(const obj of this._filters){obj._imgWidth=this._textures[0].width;obj._imgHeight=this._textures[0].height;obj.updateGeometry();}
super.resizeCanvas();}
async appendFilterObject(obj){await obj.init();obj._imgWidth=this._textures[0].width;obj._imgHeight=this._textures[0].height;obj.updateGeometry();this._filters.push(obj);}
render(){super.renderToSelectedView(this._textures[0].createView());for(let i=0;i<this._filters.length;++i){let encoder=this._device.createCommandEncoder();const computePass=encoder.beginComputePass();this._filters[i].createBindGroup(this._textures[i%2],this._textures[(i+1)%2]);this._filters[i].compute(computePass);computePass.end();const commandBuffer=encoder.finish();this._device.queue.submit([commandBuffer]);}
let encoder=this._device.createCommandEncoder();const pass=encoder.beginRenderPass({colorAttachments:[{view:this._context.getCurrentTexture().createView(),clearValue:this._clearColor,loadOp:"clear",storeOp:"store",}]});const bindGroup=this._device.createBindGroup({label:"Image Filter Renderer Bind Group",layout:this._pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:this._textures[this._filters.length%2].createView()},{binding:1,resource:this._sampler}],});pass.setPipeline(this._pipeline);pass.setBindGroup(0,bindGroup);pass.draw(6);pass.end();const commandBuffer=encoder.finish();this._device.queue.submit([commandBuffer]);}}
class SceneObject{static _objectCnt=0;constructor(device,canvasFormat){if(this.constructor==SceneObject){throw new Error("Abstract classes can't be instantiated.");}
this._device=device;this._canvasFormat=canvasFormat;SceneObject._objectCnt+=1;}
getName(){return this.constructor.name+" "+SceneObject._objectCnt.toString();}
async init(){await this.createGeometry();await this.createShaders();await this.createRenderPipeline();await this.createComputePipeline();}
async createGeometry(){throw new Error("Method 'createGeometry()' must be implemented.");}
updateGeometry(){}
loadShader(filename){return new Promise((resolve,reject)=>{const xhttp=new XMLHttpRequest();xhttp.open("GET",filename);xhttp.setRequestHeader("Cache-Control","no-cache, no-store, max-age=0");xhttp.onload=function(){if(xhttp.readyState===XMLHttpRequest.DONE&&xhttp.status===200){resolve(xhttp.responseText);}
else{reject({status:xhttp.status,statusText:xhttp.statusText});}};xhttp.onerror=function(){reject({status:xhttp.status,statusText:xhttp.statusText});};xhttp.send();});}
async createShaders(){throw new Error("Method 'createShaders()' must be implemented.");}
async createRenderPipeline(){throw new Error("Method 'createRenderPipeline()' must be implemented.");}
render(pass){throw new Error("Method 'render(pass)' must be implemented.");}
async createComputePipeline(){throw new Error("Method 'createComputePipeline()' must be implemented.");}
compute(pass){throw new Error("Method 'compute(pass)' must be implemented.");}}
class Standard2DFullScreenObject extends SceneObject{constructor(device,canvasFormat,img){super(device,canvasFormat);this._img=new Image();this._img.src=img;}
async createGeometry(){await this._img.decode();this._bitmap=await createImageBitmap(this._img);this._texture=this._device.createTexture({label:"Texture "+this.getName(),size:[this._bitmap.width,this._bitmap.height,1],format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT,});this._device.queue.copyExternalImageToTexture({source:this._bitmap},{texture:this._texture},[this._bitmap.width,this._bitmap.height]);this._sampler=this._device.createSampler({magFilter:"linear",minFilter:"linear"});}
async createShaders(){let shaderCode=await this.loadShader("/shaders/optimized_fullscreen.wgsl");this._shaderModule=this._device.createShaderModule({label:" Shader "+this.getName(),code:shaderCode,});}
async createRenderPipeline(){this._renderPipeline=this._device.createRenderPipeline({label:"Render Pipeline "+this.getName(),layout:"auto",vertex:{module:this._shaderModule,entryPoint:"vertexMain",},fragment:{module:this._shaderModule,entryPoint:"fragmentMain",targets:[{format:this._canvasFormat}]}});this._bindGroup=this._device.createBindGroup({layout:this._renderPipeline.getBindGroupLayout(0),entries:[{binding:0,resource:this._texture.createView(),},{binding:1,resource:this._sampler,}],});}
render(pass){pass.setPipeline(this._renderPipeline);pass.setBindGroup(0,this._bindGroup);pass.draw(6,1,0,0);}
async createComputePipeline(){}
compute(pass){}}
class Standard2DPGAPosedVertexColorObject extends SceneObject{constructor(device,canvasFormat,vertices,pose){super(device,canvasFormat);this._vertices=vertices;this._pose=pose;}
async createGeometry(){this._vertexBuffer=this._device.createBuffer({label:"Vertices "+this.getName(),size:this._vertices.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST,});this._device.queue.writeBuffer(this._vertexBuffer,0,this._vertices);this._vertexBufferLayout={arrayStride:6*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:0,format:"float32x2",offset:0,},{shaderLocation:1,format:"float32x4",offset:2*Float32Array.BYTES_PER_ELEMENT,}],};this._poseBuffer=this._device.createBuffer({label:"Pose "+this.getName(),size:this._pose.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,});this._device.queue.writeBuffer(this._poseBuffer,0,this._pose);}
updateGeometry(){this._device.queue.writeBuffer(this._poseBuffer,0,this._pose);}
async createShaders(){let shaderCode=await this.loadShader("/shaders/optimized_standard2dpgacolored.wgsl");this._shaderModule=this._device.createShaderModule({label:" Shader "+this.getName(),code:shaderCode,});}
async createRenderPipeline(){this._renderPipeline=this._device.createRenderPipeline({label:"Render Pipeline "+this.getName(),layout:"auto",vertex:{module:this._shaderModule,entryPoint:"vertexMain",buffers:[this._vertexBufferLayout]},fragment:{module:this._shaderModule,entryPoint:"fragmentMain",targets:[{format:this._canvasFormat}]}});this._bindGroup=this._device.createBindGroup({label:"Render Bind Group "+this.getName(),layout:this._renderPipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this._poseBuffer},}],});}
render(pass){pass.setPipeline(this._renderPipeline);pass.setVertexBuffer(0,this._vertexBuffer);pass.setBindGroup(0,this._bindGroup);pass.draw(this._vertices.length/6);}
async createComputePipeline(){}
compute(pass){}}
class LineStrip2DVertexObject extends SceneObject{constructor(device,canvasFormat,vertices){super(device,canvasFormat);this._vertices=vertices;}
async createGeometry(){this._vertexBuffer=this._device.createBuffer({label:"Vertices "+this.getName(),size:this._vertices.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST,});this._device.queue.writeBuffer(this._vertexBuffer,0,this._vertices);this._vertexBufferLayout={arrayStride:2*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:0,format:"float32x2",offset:0,}],};}
async createShaders(){let shaderCode=await this.loadShader("/shaders/optimized_standard2d.wgsl");this._shaderModule=this._device.createShaderModule({label:" Shader "+this.getName(),code:shaderCode,});}
async createRenderPipeline(){this._renderPipeline=this._device.createRenderPipeline({label:"Render Pipeline "+this.getName(),layout:"auto",vertex:{module:this._shaderModule,entryPoint:"vertexMain",buffers:[this._vertexBufferLayout]},fragment:{module:this._shaderModule,entryPoint:"fragmentMain",targets:[{format:this._canvasFormat}]},primitive:{topology:'line-strip'}});}
render(pass){pass.setPipeline(this._renderPipeline);pass.setVertexBuffer(0,this._vertexBuffer);pass.draw(this._vertices.length/2);}
async createComputePipeline(){}
compute(pass){}}
class SpaceshipObject extends Standard2DPGAPosedVertexColorObject{constructor(device,canvasFormat,pose){let _vertices=new Float32Array([-0.1,-0.15,255/255,255/255,255/255,1,-0.1,-0.45,255/255,255/255,255/255,1,0.1,-0.45,255/255,255/255,255/255,1,-0.1,-0.15,255/255,255/255,255/255,1,0.1,-0.45,255/255,255/255,255/255,1,0.1,-0.15,255/255,255/255,255/255,1,0,0.1,150/255,150/255,150/255,1,-0.1,-0.15,150/255,150/255,150/255,1,0.1,-0.15,150/255,150/255,150/255,1,0,-0.75,200/255,200/255,200/255,1,-0.1,-0.45,200/255,200/255,200/255,1,0.1,-0.45,200/255,200/255,200/255,1,0.1,-0.45,200/255,200/255,200/255,1,0,-0.75,200/255,200/255,200/255,1,0.2,-0.75,200/255,200/255,200/255,1,-0.1,-0.45,200/255,200/255,200/255,1,-0.2,-0.75,200/255,200/255,200/255,1,0,-0.75,200/255,200/255,200/255,1,]);super(device,canvasFormat,_vertices,pose);this._interval=50;this._t=0;this._step=1;this._pose0=[-1,0,0.5,-0.5,0.5,0.5];this._pose1=[0,1,-0.5,0.5,0.5,0.5];this._pose2=[-1,0,-0.5,0.5,0.5,0.5];this._poses=[this._pose0,this._pose1,this._pose2];this._p=0;}
updateGeometry(){var pNext=this._p+this._step;this._pose[0]=this._poses[this._p][0]*(1-this._t/this._interval)+this._poses[pNext][0]*this._t/this._interval;this._pose[1]=this._poses[this._p][1]*(1-this._t/this._interval)+this._poses[pNext][1]*this._t/this._interval;this._pose[2]=this._poses[this._p][2]*(1-this._t/this._interval)+this._poses[pNext][2]*this._t/this._interval;this._pose[3]=this._poses[this._p][3]*(1-this._t/this._interval)+this._poses[pNext][3]*this._t/this._interval;this._t+=1;if(this._t>=this._interval){this._p=this._p+this._step;this._t=0;if(this._p==this._poses.length-1){this._step=-1;}else if(this._p==0){this._step=1;}}
super.updateGeometry();}}
class Standard2DPGAPosedTextureObject extends SceneObject{constructor(device,canvasFormat,vertices,pose,img){super(device,canvasFormat);this._vertices=vertices;this._pose=pose;console.log(img);this._img=new Image();this._img.src=img;}
async createGeometry(){await this._img.decode();this._bitmap=await createImageBitmap(this._img);this._texture=this._device.createTexture({label:"Texture "+this.getName(),size:[this._bitmap.width,this._bitmap.height,1],format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT,});this._device.queue.copyExternalImageToTexture({source:this._bitmap},{texture:this._texture},[this._bitmap.width,this._bitmap.height]);this._sampler=this._device.createSampler({magFilter:"linear",minFilter:"linear"});this._vertexBuffer=this._device.createBuffer({label:"Vertices "+this.getName(),size:this._vertices.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST,});this._device.queue.writeBuffer(this._vertexBuffer,0,this._vertices);this._vertexBufferLayout={arrayStride:6*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:0,format:"float32x2",offset:0,},{shaderLocation:1,format:"float32x4",offset:2*Float32Array.BYTES_PER_ELEMENT,}],};this._poseBuffer=this._device.createBuffer({label:"Pose "+this.getName(),size:this._pose.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,});this._device.queue.writeBuffer(this._poseBuffer,0,this._pose);}
updateGeometry(){this._device.queue.writeBuffer(this._poseBuffer,0,this._pose);}
async createShaders(){let shaderCode=await this.loadShader("/shaders/optimized_standard2dpgatexture.wgsl");this._shaderModule=this._device.createShaderModule({label:" Shader "+this.getName(),code:shaderCode,});}
async createRenderPipeline(){this._renderPipeline=this._device.createRenderPipeline({label:"Render Pipeline "+this.getName(),layout:"auto",vertex:{module:this._shaderModule,entryPoint:"vertexMain",buffers:[this._vertexBufferLayout]},fragment:{module:this._shaderModule,entryPoint:"fragmentMain",targets:[{format:this._canvasFormat,blend:{color:{srcFactor:'one',dstFactor:'one-minus-src-alpha'},alpha:{srcFactor:'one',dstFactor:'one-minus-src-alpha'},},}]}});this._bindGroup=this._device.createBindGroup({label:"Render Bind Group "+this.getName(),layout:this._renderPipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this._poseBuffer},},{binding:1,resource:this._texture.createView(),},{binding:2,resource:this._sampler,}],});}
render(pass){pass.setPipeline(this._renderPipeline);pass.setVertexBuffer(0,this._vertexBuffer);pass.setBindGroup(0,this._bindGroup);pass.draw(this._vertices.length/6);}
async createComputePipeline(){}
compute(pass){}}
class PGA2D{static geometricProduct(a,b){return[a[0]*b[0]-a[1]*b[1],a[0]*b[1]+a[1]*b[0],a[0]*b[2]+a[1]*b[3]+a[2]*b[0]-a[3]*b[1],a[0]*b[3]-a[1]*b[2]+a[2]*b[1]+a[3]*b[0]];}
static reverse(a){return[a[0],-a[1],-a[2],-a[3]];}
static applyMotor(p,m){return PGA2D.geometricProduct(m,PGA2D.geometricProduct(p,PGA2D.reverse(m)));}
static motorNorm(m){return Math.sqrt(m[0]*m[0]+m[1]*m[1]+m[2]*m[2]+m[3]*m[3]);}
static createTranslator(dx,dy){return[1,0,dy/2,-dx/2]}
static createRotor(angle,cx=0,cy=0){return[Math.cos(angle/2),-Math.sin(angle/2),-cx*Math.sin(angle/2),-cy*Math.sin(angle/2)];}
static normaliozeMotor(m){let mnorm=PGA2D.motorNorm(m);if(mnorm==0.0){return[1,0,0,0];}
return[m[0]/mnorm,m[1]/mnorm,m[2]/mnorm,m[3]/mnorm];}
static applyMotorToPoint(p,m){let new_p=PGA2D.applyMotor([0,1,p[0],p[1]],m);return[new_p[2]/new_p[1],new_p[3]/new_p[1]];};}
class PlanetObject extends Standard2DPGAPosedTextureObject{constructor(device,canvasFormat,pose,start,image){let _vertices=new Float32Array([start[0]+-0.1,start[1]+-0.1,255/255,255/255,255/255,1,start[0]+-0.1,start[1]+0.1,255/255,255/255,255/255,1,start[0]+0.1,start[1]+-0.1,255/255,255/255,255/255,1,start[0]+0.1,start[1]+-0.1,255/255,255/255,255/255,1,start[0]+0.1,start[1]+0.1,255/255,255/255,255/255,1,start[0]+-0.1,start[1]+0.1,255/255,255/255,255/255,1,]);console.log(image);super(device,canvasFormat,_vertices,pose,image);this.rotSpeed=pose[5]}
updateGeometry(){let angle=Math.PI/200/(this.rotSpeed);let pivot=[0,0];let T_negP=[1,0,-pivot[0]/2,-pivot[1]/2];let T_posP=[1,0,pivot[0]/2,pivot[1]/2];let dr=PGA2D.normaliozeMotor([Math.cos(angle/2),-Math.sin(angle/2),0,0]);let temp1=PGA2D.geometricProduct(T_negP,this._pose);let temp2=PGA2D.geometricProduct(dr,temp1);let temp3=PGA2D.geometricProduct(T_posP,temp2);let newmotor=PGA2D.normaliozeMotor(temp3);this._pose[0]=newmotor[0];this._pose[1]=newmotor[1];this._pose[2]=newmotor[2];this._pose[3]=newmotor[3];super.updateGeometry();}}
class MoonObject extends Standard2DPGAPosedVertexColorObject{constructor(device,canvasFormat,pose,start){let _vertices=new Float32Array([start[0]+-0.1,start[1]+-0.1,255/255,255/255,255/255,1,start[0]+-0.1,start[1]+0.1,255/255,255/255,255/255,1,start[0]+0.1,start[1]+-0.1,255/255,255/255,255/255,1,start[0]+0.1,start[1]+-0.1,255/255,255/255,255/255,1,start[0]+0.1,start[1]+0.1,255/255,255/255,255/255,1,start[0]+-0.1,start[1]+0.1,255/255,255/255,255/255,1,]);super(device,canvasFormat,_vertices,pose);this._pivot=start;}
updateGeometry(){this.updatePivot();let angle=Math.PI/100;let pivot=this._pivot;let T_negP=[1,0,-pivot[0]/2,-pivot[1]/2];let T_posP=[1,0,pivot[0]/2,pivot[1]/2];let dr=PGA2D.normaliozeMotor([Math.cos(angle/2),-Math.sin(angle/2),0,0]);let temp1=PGA2D.geometricProduct(T_negP,this._pose);let temp2=PGA2D.geometricProduct(dr,temp1);let temp3=PGA2D.geometricProduct(T_posP,temp2);let newmotor=PGA2D.normaliozeMotor(temp3);this._pose[0]=newmotor[0];this._pose[1]=newmotor[1];this._pose[2]=newmotor[2];this._pose[3]=newmotor[3];super.updateGeometry();}
updatePivot(){let angle=Math.PI/100;let pivot=[0,0];let T_negP=[1,0,-pivot[0]/2,-pivot[1]/2];let T_posP=[1,0,pivot[0]/2,pivot[1]/2];let dr=PGA2D.normaliozeMotor([Math.cos(angle/2),-Math.sin(angle/2),0,0]);let temp1=PGA2D.geometricProduct(T_negP,this._pose);let temp2=PGA2D.geometricProduct(dr,temp1);let temp3=PGA2D.geometricProduct(T_posP,temp2);let newmotor=PGA2D.normaliozeMotor(temp3);this._pivot[0]=newmotor[2];this._pivot[1]=newmotor[3];}}
async function init(){const canvasTag=document.createElement('canvas');canvasTag.id="renderCanvas";document.body.appendChild(canvasTag);const renderer=new FilteredRenderer(canvasTag);await renderer.init();await renderer.appendSceneObject(new Standard2DFullScreenObject(renderer._device,renderer._canvasFormat,"/assets/space.jpg"));var vertices1=new Float32Array([0,0.5,1,0,0,1,-0.5,0,0,1,0,1,0.5,0,0,0,1,1,]);var pose=[1,0,0,0,1,1];pose=new Float32Array(pose);var vertices2=new Float32Array([0,-0.6,-0.5,-0.1,0.5,-0.1,0,-0.6,]);await renderer.appendSceneObject(new PlanetObject(renderer._device,renderer._canvasFormat,new Float32Array([1,0,0,0,1.5,1.5]),new Float32Array([0,0]),"/assets/sun.png"));await renderer.appendSceneObject(new PlanetObject(renderer._device,renderer._canvasFormat,new Float32Array([1,0,0,0,0.2,0.2]),new Float32Array([0.80,0]),"/assets/mercury.png"));await renderer.appendSceneObject(new PlanetObject(renderer._device,renderer._canvasFormat,new Float32Array([1,0,0,0,0.3,0.3]),new Float32Array([0.80,0]),"/assets/venus.png"));await renderer.appendSceneObject(new PlanetObject(renderer._device,renderer._canvasFormat,new Float32Array([1,0,0,0,0.4,0.4]),new Float32Array([0.85,0]),"/assets/earth.png"));await renderer.appendSceneObject(new PlanetObject(renderer._device,renderer._canvasFormat,new Float32Array([1,0,0,0,0.5,0.5]),new Float32Array([0.85,0]),"/assets/mars.png"));await renderer.appendSceneObject(new PlanetObject(renderer._device,renderer._canvasFormat,new Float32Array([1,0,0,0,0.9,0.9]),new Float32Array([0.65,0]),"/assets/jupiter.png"));await renderer.appendSceneObject(new PlanetObject(renderer._device,renderer._canvasFormat,new Float32Array([1,0,0,0,0.7,0.7]),new Float32Array([1.05,0]),"/assets/saturn.png"));await renderer.appendSceneObject(new PlanetObject(renderer._device,renderer._canvasFormat,new Float32Array([1,0,0,0,0.6,0.6]),new Float32Array([1.5,0]),"/assets/uranus.png"));await renderer.appendSceneObject(new PlanetObject(renderer._device,renderer._canvasFormat,new Float32Array([1,0,0,0,0.65,0.65]),new Float32Array([1.7,0]),"/assets/neptune.png"));await renderer.appendSceneObject(new SpaceshipObject(renderer._device,renderer._canvasFormat,new Float32Array([1,0,0,0,0.5,0.5])));setInterval(()=>{renderer.render();},100);return renderer;}
init().then(ret=>{console.log(ret);}).catch(error=>{const pTag=document.createElement('p');pTag.innerHTML=navigator.userAgent+"</br>"+error.message;document.body.appendChild(pTag);document.getElementById("renderCanvas").remove();});