<!DOCTYPE html>
<html>
    <meta>
        <link rel="stylesheet" type="text/css" href="display.css">
        <script type="module" src="https://cdn.jsdelivr.net/npm/zero-md@3?register"></script>
    </meta>
<head>
    <title>TJ's Arcane Portal</title>
</head>
<body>
    <script>
        class Renderer{constructor(canvas){this._canvas=canvas;this._objects=[];this._clearColor={r:0,g:56/255,b:101/255,a:1};}
async init(){if(!navigator.gpu){throw Error("WebGPU is not supported in this browser.");}
const adapter=await navigator.gpu.requestAdapter();if(!adapter){throw Error("Couldn't request WebGPU adapter.");}
this._device=await adapter.requestDevice();this._context=this._canvas.getContext("webgpu");this._canvasFormat=navigator.gpu.getPreferredCanvasFormat();this._context.configure({device:this._device,format:this._canvasFormat,});this.resizeCanvas();window.addEventListener('resize',this.resizeCanvas.bind(this));}
resizeCanvas(){const devicePixelRatio=window.devicePixelRatio||1;const width=window.innerWidth*devicePixelRatio;const height=window.innerHeight*devicePixelRatio;this._canvas.width=width;this._canvas.height=height;this._canvas.style.width=`${window.innerWidth}px`;this._canvas.style.height=`${window.innerHeight}px`;this._canvas.style.transformOrigin="center";this.render();}
async appendSceneObject(obj){await obj.init();this._objects.push(obj);}
renderToSelectedView(outputView){for(const obj of this._objects){obj?.updateGeometry();}
let encoder=this._device.createCommandEncoder();const pass=encoder.beginRenderPass({colorAttachments:[{view:outputView,clearValue:this._clearColor,loadOp:"clear",storeOp:"store",}]});for(const obj of this._objects){obj?.render(pass);}
pass.end();const computePass=encoder.beginComputePass();for(const obj of this._objects){obj?.compute(computePass);}
computePass.end();const commandBuffer=encoder.finish();this._device.queue.submit([commandBuffer]);}
render(){this.renderToSelectedView(this._context.getCurrentTexture().createView());}}
class RayTracer extends Renderer{constructor(canvas){super(canvas);this._tracer=null;}
async init(){if(!navigator.gpu){throw Error("WebGPU is not supported in this browser.");}
const adapter=await navigator.gpu.requestAdapter();if(!adapter){throw Error("Couldn't request WebGPU adapter.");}
this._device=await adapter.requestDevice();this._context=this._canvas.getContext("webgpu");this._canvasFormat="rgba8unorm";this._context.configure({device:this._device,format:this._canvasFormat,});this._shaderModule=this._device.createShaderModule({label:"Ray Tracer Shader",code:`
      @vertex
      fn vertexMain(@builtin(vertex_index) vIdx: u32) -> @builtin(position) vec4f {
        var pos = array<vec2f, 6>(
          vec2f(-1, -1), vec2f(1, -1), vec2f(-1, 1),
          vec2f(-1, 1), vec2f(1, -1), vec2f(1, 1)
        );
        return vec4f(pos[vIdx], 0, 1);
      }
      
      @group(0) @binding(0) var inTexture: texture_2d<f32>;
      @group(0) @binding(1) var inSampler: sampler;
      @group(0) @binding(2) var<uniform> imgSize: vec2f;
      
      @fragment
      fn fragmentMain(@builtin(position) fragCoord: vec4f) -> @location(0) vec4f {
        let uv = fragCoord.xy / imgSize; // vec2f(textureDimensions(inTexture, 0));
        return textureSample(inTexture, inSampler, uv);
      }
      `});this._outputSizeBuffer=this._device.createBuffer({label:"Ray Tracer output size buffer",size:8,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,});this._pipeline=this._device.createRenderPipeline({label:"Ray Tracer Pipeline",layout:"auto",vertex:{module:this._shaderModule,entryPoint:"vertexMain",},fragment:{module:this._shaderModule,entryPoint:"fragmentMain",targets:[{format:this._canvasFormat}]}});this._sampler=this._device.createSampler({label:"Ray Tracer Sampler",magFilter:"linear",minFilter:"linear"});this.resizeCanvas();window.addEventListener('resize',this.resizeCanvas.bind(this));}
resizeCanvas(){const devicePixelRatio=window.devicePixelRatio||1;const width=window.innerWidth*devicePixelRatio;const height=window.innerHeight*devicePixelRatio;const ratio=width/height;const tgtHeight=height;let imgSize={width:tgtHeight*ratio,height:tgtHeight};this._offScreenTexture=this._device.createTexture({size:imgSize,format:this._canvasFormat,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING,});if(this._tracer){this._tracer._imgWidth=this._offScreenTexture.width;this._tracer._imgHeight=this._offScreenTexture.height;this._tracer.updateGeometry();this._tracer.createBindGroup(this._offScreenTexture);}
this._bindGroup=this._device.createBindGroup({label:"Ray Tracer Renderer Bind Group",layout:this._pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:this._offScreenTexture.createView()},{binding:1,resource:this._sampler},{binding:2,resource:{buffer:this._outputSizeBuffer}}],});super.resizeCanvas();this._device.queue.writeBuffer(this._outputSizeBuffer,0,new Float32Array([width,height]));}
async setTracerObject(obj){await obj.init();obj._imgWidth=this._offScreenTexture.width;obj._imgHeight=this._offScreenTexture.height;obj.updateGeometry();this._tracer=obj;this._tracer.createBindGroup(this._offScreenTexture);}
render(){if(this._tracer){let encoder=this._device.createCommandEncoder();const computePass=encoder.beginComputePass();this._tracer.compute(computePass);computePass.end();this._device.queue.submit([encoder.finish()]);}
let encoder=this._device.createCommandEncoder();const pass=encoder.beginRenderPass({colorAttachments:[{view:this._context.getCurrentTexture().createView(),clearValue:this._clearColor,loadOp:"clear",storeOp:"store",}]});pass.setPipeline(this._pipeline);pass.setBindGroup(0,this._bindGroup);pass.draw(6);pass.end();this._device.queue.submit([encoder.finish()]);}}
class StandardTextObject{constructor(inputText,right='',left='10',top='10',spacing=5,textFont='18px Arial'){this._textFont=textFont;this._lineSpacing=spacing;this._textCanvas=document.createElement('canvas');this._textContext=this._textCanvas.getContext('2d');this.updateTextRegion(inputText);this.updateText(inputText);this._textCanvas.style.position='absolute';if(right!=''){this._textCanvas.style.right=right+'px';}else{this._textCanvas.style.left=left+'px';}
this._textCanvas.style.top=top+'px';this._textCanvas.style.border='1px solid red';document.body.appendChild(this._textCanvas);}
toggleVisibility(){this._textCanvas.hidden=!this._textCanvas.hidden;}
updateTextRegion(newText){this._textContext.font=this._textFont;this._lines=newText.split('\n');this._width=Math.max(...this._lines.map(line=>this._textContext.measureText(line).width));const match=this._textFont.match(/(\d+)px/);if(match){this._fontSize=parseInt(match[1],10);}
else{this._fontSize=18;this._textFont="18px Arial";}
this._height=this._lines.length*(this._fontSize+this._lineSpacing);this._paddingx=5;this._paddingtop=3;this._canvasWidth=Math.ceil(this._width+this._paddingx*2);this._canvasHeight=Math.ceil(this._height+this._paddingtop);this._textCanvas.width=this._canvasWidth;this._textCanvas.height=this._canvasHeight;this._textContext.font=this._textFont;this._textContext.textBaseline='top';}
updateText(newText){this._lines=newText.split('\n');this._textContext.fillStyle='rgba(1, 1, 1, 0.5)';this._textContext.clearRect(0,0,this._canvasWidth,this._canvasHeight);this._textContext.fillRect(0,0,this._canvasWidth,this._canvasHeight);this._textContext.fillStyle='white';this._lines.forEach((line,idx)=>{const x=this._paddingx;const y=this._paddingtop+idx*(this._fontSize+this._lineSpacing);this._textContext.fillText(line,x,y);});}}
class SceneObject{static _objectCnt=0;constructor(device,canvasFormat){if(this.constructor==SceneObject){throw new Error("Abstract classes can't be instantiated.");}
this._device=device;this._canvasFormat=canvasFormat;SceneObject._objectCnt+=1;}
getName(){return this.constructor.name+" "+SceneObject._objectCnt.toString();}
async init(){await this.createGeometry();await this.createShaders();await this.createRenderPipeline();await this.createComputePipeline();}
async createGeometry(){throw new Error("Method 'createGeometry()' must be implemented.");}
updateGeometry(){}
loadShader(filename){return new Promise((resolve,reject)=>{const xhttp=new XMLHttpRequest();xhttp.open("GET",filename);xhttp.setRequestHeader("Cache-Control","no-cache, no-store, max-age=0");xhttp.onload=function(){if(xhttp.readyState===XMLHttpRequest.DONE&&xhttp.status===200){resolve(xhttp.responseText);}
else{reject({status:xhttp.status,statusText:xhttp.statusText});}};xhttp.onerror=function(){reject({status:xhttp.status,statusText:xhttp.statusText});};xhttp.send();});}
async createShaders(){throw new Error("Method 'createShaders()' must be implemented.");}
async createRenderPipeline(){throw new Error("Method 'createRenderPipeline()' must be implemented.");}
render(pass){throw new Error("Method 'render(pass)' must be implemented.");}
async createComputePipeline(){throw new Error("Method 'createComputePipeline()' must be implemented.");}
compute(pass){throw new Error("Method 'compute(pass)' must be implemented.");}}
class RayTracingObject extends SceneObject{async createGeometry(){}
async createShaders(){let shaderCode=await this.loadShader("/shaders/optimized_tracenothing.wgsl");this._shaderModule=this._device.createShaderModule({label:" Shader "+this.getName(),code:shaderCode,});}
updateGeometry(){}
async createRenderPipeline(){}
render(pass){}
async createComputePipeline(){this._computePipeline=this._device.createComputePipeline({label:"Ray Tracing Pipeline "+this.getName(),layout:"auto",compute:{module:this._shaderModule,entryPoint:"computeMain",}});}
createBindGroup(outTexture){this._bindGroup=this._device.createBindGroup({label:"Ray Tracing Bind Group",layout:this._computePipeline.getBindGroupLayout(0),entries:[{binding:0,resource:outTexture.createView()}],});this._wgWidth=Math.ceil(outTexture.width);this._wgHeight=Math.ceil(outTexture.height);}
compute(pass){pass.setPipeline(this._computePipeline);pass.setBindGroup(0,this._bindGroup);pass.dispatchWorkgroups(Math.ceil(this._wgWidth/16),Math.ceil(this._wgHeight/16));}}
class UnitCube{constructor(){this._pose=new Float32Array(Array(16).fill(0));this._pose[0]=1;this._scales=new Float32Array(Array(4).fill(1));this._front=new Float32Array([-0.5,-0.5,0.5,1,0.5,-0.5,0.5,1,0.5,0.5,0.5,1,-0.5,0.5,0.5,1,]);this._back=new Float32Array([-0.5,-0.5,-0.5,1,0.5,-0.5,-0.5,1,0.5,0.5,-0.5,1,-0.5,0.5,-0.5,1,]);this._left=new Float32Array([-0.5,-0.5,-0.5,1,-0.5,-0.5,0.5,1,-0.5,0.5,0.5,1,-0.5,0.5,-0.5,1,]);this._right=new Float32Array([0.5,-0.5,-0.5,1,0.5,-0.5,0.5,1,0.5,0.5,0.5,1,0.5,0.5,-0.5,1,]);this._top=new Float32Array([-0.5,0.5,-0.5,1,0.5,0.5,-0.5,1,0.5,0.5,0.5,1,-0.5,0.5,0.5,1,]);this._down=new Float32Array([-0.5,-0.5,-0.5,1,0.5,-0.5,-0.5,1,0.5,-0.5,0.5,1,-0.5,-0.5,0.5,1,]);}
updatePose(newPose){for(let i=0;i<16;++i)this._pose[i]=newPose[i];}}
class RayTracingBoxLightObject extends RayTracingObject{constructor(device,canvasFormat,camera,showTexture=true){super(device,canvasFormat);this._box=new UnitCube();this._camera=camera;this._showTexture=showTexture;this._mode=0;this._lightIndex=0;}
async createGeometry(){this._cameraBuffer=this._device.createBuffer({label:"Camera "+this.getName(),size:this._camera._pose.byteLength+this._camera._focal.byteLength+this._camera._resolutions.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,});this._device.queue.writeBuffer(this._cameraBuffer,0,this._camera._pose);this._device.queue.writeBuffer(this._cameraBuffer,this._camera._pose.byteLength,this._camera._focal);this._device.queue.writeBuffer(this._cameraBuffer,this._camera._pose.byteLength+this._camera._focal.byteLength,this._camera._resolutions);this._boxBuffer=this._device.createBuffer({label:"Box "+this.getName(),size:this._box._pose.byteLength+this._box._scales.byteLength+this._box._top.byteLength*6,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,});let offset=0;this._device.queue.writeBuffer(this._boxBuffer,offset,this._box._pose);offset+=this._box._pose.byteLength;this._device.queue.writeBuffer(this._boxBuffer,offset,this._box._scales);offset+=this._box._scales.byteLength;this._device.queue.writeBuffer(this._boxBuffer,offset,this._box._front);offset+=this._box._front.byteLength;this._device.queue.writeBuffer(this._boxBuffer,offset,this._box._back);offset+=this._box._back.byteLength;this._device.queue.writeBuffer(this._boxBuffer,offset,this._box._left);offset+=this._box._left.byteLength;this._device.queue.writeBuffer(this._boxBuffer,offset,this._box._right);offset+=this._box._right.byteLength;this._device.queue.writeBuffer(this._boxBuffer,offset,this._box._top);offset+=this._box._top.byteLength;this._device.queue.writeBuffer(this._boxBuffer,offset,this._box._down);this._lightBuffer=this._device.createBuffer({label:"Light "+this.getName(),size:20*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,});this._modeBuffer=this._device.createBuffer({label:"Mode "+this.getName(),size:16,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,});this._device.queue.writeBuffer(this._modeBuffer,0,new Uint32Array([this._mode]));}
updateGeometry(){this._camera.updateSize(this._imgWidth,this._imgHeight);this._device.queue.writeBuffer(this._cameraBuffer,this._camera._pose.byteLength+this._camera._focal.byteLength,this._camera._resolutions);}
updateBoxPose(){this._device.queue.writeBuffer(this._boxBuffer,0,this._box._pose);}
updateBoxScales(){this._device.queue.writeBuffer(this._boxBuffer,this._box._pose.byteLength,this._box._scales);}
updateCameraPose(){this._device.queue.writeBuffer(this._cameraBuffer,0,this._camera._pose);}
updateCameraFocal(){this._device.queue.writeBuffer(this._cameraBuffer,this._camera._pose.byteLength,this._camera._focal);}
async updateMode(){console.log(this._mode);this._device.queue.writeBuffer(this._modeBuffer,0,new Uint32Array([this._mode]));}
updateLight(light){console.log(light)
let offset=0;this._device.queue.writeBuffer(this._lightBuffer,offset,light._intensity);offset+=light._intensity.byteLength;this._device.queue.writeBuffer(this._lightBuffer,offset,light._position);offset+=light._position.byteLength;this._device.queue.writeBuffer(this._lightBuffer,offset,light._direction);offset+=light._direction.byteLength;this._device.queue.writeBuffer(this._lightBuffer,offset,light._attenuation);offset+=light._attenuation.byteLength;this._device.queue.writeBuffer(this._lightBuffer,offset,light._params);}
async createShaders(){let shaderCode=await this.loadShader("/shaders/optimized_traceboxlight.wgsl");this._shaderModule=this._device.createShaderModule({label:" Shader "+this.getName(),code:shaderCode,});this._bindGroupLayout=this._device.createBindGroupLayout({label:"Ray Trace Box Layout "+this.getName(),entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{}},{binding:2,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:this._canvasFormat}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{}},{binding:4,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}]});this._pipelineLayout=this._device.createPipelineLayout({label:"Ray Trace Box Pipeline Layout",bindGroupLayouts:[this._bindGroupLayout],});}
async createComputePipeline(){this._computePipeline=this._device.createComputePipeline({label:"Ray Trace Box Orthogonal Pipeline "+this.getName(),layout:this._pipelineLayout,compute:{module:this._shaderModule,entryPoint:"computeOrthogonalMain",}});this._computeProjectivePipeline=this._device.createComputePipeline({label:"Ray Trace Box Projective Pipeline "+this.getName(),layout:this._pipelineLayout,compute:{module:this._shaderModule,entryPoint:"computeProjectiveMain",}});}
createBindGroup(outTexture){this._bindGroup=this._device.createBindGroup({label:"Ray Trace Box Bind Group",layout:this._computePipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this._cameraBuffer}},{binding:1,resource:{buffer:this._boxBuffer}},{binding:2,resource:outTexture.createView()},{binding:3,resource:{buffer:this._lightBuffer}},{binding:4,resource:{buffer:this._modeBuffer}}],});this._wgWidth=Math.ceil(outTexture.width);this._wgHeight=Math.ceil(outTexture.height);}
compute(pass){if(this._camera?._isProjective){pass.setPipeline(this._computeProjectivePipeline);}
else{pass.setPipeline(this._computePipeline);}
pass.setBindGroup(0,this._bindGroup);pass.dispatchWorkgroups(Math.ceil(this._wgWidth/16),Math.ceil(this._wgHeight/16));}}
class PGA3D{static geometricProduct(a,b){return[a[0]*b[0]-a[1]*b[1]-a[2]*b[2]-a[3]*b[3]-a[7]*b[7]+a[11]*b[11]+a[12]*b[12]+a[13]*b[13],a[0]*b[1]+a[1]*b[0]-a[2]*b[3]+a[3]*b[2]+a[7]*b[13]+a[11]*b[12]-a[12]*b[11]+a[13]*b[7],a[0]*b[2]+a[1]*b[3]+a[2]*b[0]-a[3]*b[1]-a[7]*b[12]+a[11]*b[13]-a[12]*b[7]-a[13]*b[11],a[0]*b[3]-a[1]*b[2]+a[2]*b[1]+a[3]*b[0]+a[7]*b[11]+a[11]*b[7]+a[12]*b[13]-a[13]*b[12],a[0]*b[4]+a[1]*b[5]+a[2]*b[6]-a[3]*b[15]+a[4]*b[0]-a[5]*b[1]-a[6]*b[2]+a[7]*b[10]+a[8]*b[12]+a[9]*b[13]-a[10]*b[7]-a[11]*b[14]+a[12]*b[8]+a[13]*b[9]+a[14]*b[11]-a[15]*b[3],a[0]*b[5]-a[1]*b[4]+a[2]*b[15]+a[3]*b[6]+a[4]*b[1]+a[5]*b[0]-a[6]*b[3]-a[7]*b[9]-a[8]*b[11]+a[9]*b[7]+a[10]*b[12]-a[11]*b[8]-a[12]*b[14]+a[13]*b[10]+a[14]*b[12]+a[15]*b[2],a[0]*b[6]-a[1]*b[15]-a[2]*b[4]-a[3]*b[5]+a[4]*b[2]+a[5]*b[3]+a[6]*b[0]+a[7]*b[8]-a[8]*b[7]-a[9]*b[11]-a[10]*b[12]-a[11]*b[9]-a[12]*b[10]-a[13]*b[14]+a[14]*b[13]-a[15]*b[1],a[0]*b[7]+a[1]*b[13]-a[2]*b[12]+a[3]*b[11]+a[7]*b[0]+a[11]*b[3]-a[12]*b[2]+a[13]*b[1],a[0]*b[8]+a[1]*b[14]-a[2]*b[10]+a[3]*b[9]+a[4]*b[12]-a[5]*b[11]+a[6]*b[7]-a[7]*b[6]+a[8]*b[0]-a[9]*b[3]+a[10]*b[2]-a[11]*b[5]+a[12]*b[4]-a[13]*b[15]+a[14]*b[1]+a[15]*b[13],a[0]*b[9]+a[1]*b[10]+a[2]*b[14]-a[3]*b[8]+a[4]*b[13]-a[5]*b[7]-a[6]*b[11]+a[7]*b[5]+a[8]*b[3]+a[9]*b[0]-a[10]*b[1]-a[11]*b[6]+a[12]*b[15]+a[13]*b[4]+a[14]*b[2]-a[15]*b[12],a[0]*b[10]-a[1]*b[9]+a[2]*b[8]+a[3]*b[14]+a[4]*b[7]+a[5]*b[13]-a[6]*b[12]-a[7]*b[4]-a[8]*b[2]+a[9]*b[1]+a[10]*b[0]-a[11]*b[15]-a[12]*b[6]+a[13]*b[5]+a[14]*b[3]+a[15]*b[11],a[0]*b[11]+a[1]*b[12]+a[2]*b[13]-a[3]*b[7]-a[7]*b[3]+a[11]*b[0]-a[12]*b[1]-a[13]*b[2],a[0]*b[12]-a[1]*b[11]+a[2]*b[7]+a[3]*b[13]+a[7]*b[2]+a[11]*b[1]+a[12]*b[0]-a[13]*b[3],a[0]*b[13]-a[1]*b[7]-a[2]*b[11]-a[3]*b[12]-a[7]*b[1]+a[11]*b[2]+a[12]*b[3]+a[13]*b[0],a[0]*b[14]-a[1]*b[8]-a[2]*b[9]-a[3]*b[10]+a[4]*b[11]+a[5]*b[12]+a[6]*b[13]+a[7]*b[15]-a[8]*b[1]-a[9]*b[2]-a[10]*b[3]-a[11]*b[4]-a[12]*b[5]-a[13]*b[6]+a[14]*b[0]-a[15]*b[7],a[0]*b[15]+a[1]*b[6]-a[2]*b[5]+a[3]*b[4]+a[4]*b[3]-a[5]*b[2]+a[6]*b[1]-a[7]*b[14]+a[8]*b[13]-a[9]*b[12]+a[10]*b[11]-a[11]*b[10]+a[12]*b[9]-a[13]*b[8]+a[14]*b[7]+a[15]*b[0],];}
static reverse(a){return[a[0],-a[1],-a[2],-a[3],-a[4],-a[5],-a[6],-a[7],-a[8],-a[9],-a[10],a[11],a[12],a[13],a[14],a[15]];}
static applyMotor(p,m){return PGA3D.geometricProduct(m,PGA3D.geometricProduct(p,PGA3D.reverse(m)));}
static motorNorm(m){return Math.sqrt(m.map(val=>val*val).reduce((s,val)=>s+val,0));}
static createTranslator(dx,dy,dz){return[1,0,0,0,-dx/2,-dy/2,-dz/2,0,0,0,0,0,0,0,0,0];}
static extractTranslator(m){return[1,0,0,0,m[4],m[5],m[6],0,0,0,0,0,0,0,0,0];}
static createRotor(angle,dx=1,dy=0,dz=0,sx=0,sy=0,sz=0){let c=Math.cos(angle/2);let s=Math.sin(angle/2);let L=PGA3D.createLine(sx,sy,sz,dx,dy,dz);return[c,s*L[1],s*L[2],s*L[3],s*L[4],s*L[5],s*L[6],0,0,0,0,0,0,0,0,0];}
static extractRotor(m){return[m[0],m[1],m[2],m[3],0,0,0,0,0,0,0,0,0,0,0,0];}
static createDir(dx,dy,dz){return[0,dz,-dy,dx,0,0,0,0,0,0,0,0,0,0,0,0];}
static createLine(sx,sy,sz,dx,dy,dz){let n=PGA3D.createDir(dx,dy,dz);let dir=PGA3D.normalizeMotor(n);return[0,dir[1],dir[2],dir[3],-(-dir[2]*sz-dir[1]*sy),-(dir[1]*sx-dir[3]*sz),-(dir[3]*sy+dir[2]*sx),0,0,0,0,0,0,0,0,0];}
static createPoint(x,y,z){return[0,0,0,0,0,0,0,1,-z,y,-x,0,0,0,0,0];}
static extractPoint(p){return[-p[10]/p[7],p[9]/p[7],-p[8]/p[7]];}
static createPlane(nx,ny,nz,d){return[0,0,0,0,0,0,0,0,0,0,0,nx,ny,nz,-d,0];}
static createPlaneFromPoints(p1,p2,p3){let nx=(p2[1]*p3[2]-p3[1]*p2[2])-(p1[1]*p3[2]-p3[1]*p1[2])+(p1[1]*p2[2]-p2[1]*p1[2]);let ny=(p2[0]*p3[2]-p3[0]*p2[2])-(p1[0]*p3[2]-p3[0]*p1[2])+(p1[0]*p2[2]-p2[0]*p1[2]);let nz=(p2[0]*p3[1]-p3[0]*p2[1])-(p1[0]*p3[1]-p3[0]*p1[1])+(p1[0]*p2[1]-p2[0]*p1[1]);let d=(p1[0]*(p2[1]*p3[2]-p3[1]*p2[2])-p2[0]*(p1[1]*p3[2]-p3[1]*p1[2])+p3[0]*(p1[1]*p2[2]-p2[1]*p1[2]));return PGA3D.createPlane(nx,-ny,nz,d);}
static linePlaneIntersection(L,P){let new_p=PGA3D.geometricProduct(L,P);let isParallel=(Math.abs(new_p[7])<=0.00000001);let inPlane=isParallel&&(Math.abs(new_p[8])<=0.00000001)&&(Math.abs(new_p[9])<=0.00000001)&&(Math.abs(new_p[10])<=0.00000001);return[PGA3D.extractPoint(new_p),!isParallel,inPlane];}
static normalizeMotor(m){let mnorm=PGA3D.motorNorm(m);if(mnorm==0.0){return[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];}
return m.map(val=>val/mnorm);}
static applyMotorToPoint(p,m){let new_p=PGA3D.applyMotor(PGA3D.createPoint(p[0],p[1],p[2]),m);return PGA3D.extractPoint(new_p);};static applyMotorToDir(d,m){let r=PGA3D.extractRotor(m);let new_d=PGA3D.applyMotor(PGA3D.createPoint(d[0],d[1],d[2]),r);return PGA3D.extractPoint(new_d);}
static isInside(v0,v1,v2,p){let pga0=PGA3D.createPoint(v0[0],v0[1],v0[2]);let pga1=PGA3D.createPoint(v1[0],v1[1],v1[2]);let pga2=PGA3D.createPoint(v2[0],v2[1],v2[2]);let pgap=PGA3D.createPoint(p[0],p[1],p[2]);let plane012=PGA3D.createPlaneFromPoints(v0,v1,v2);let planep12=PGA3D.createPlaneFromPoints(p,v1,v2);let plane0p2=PGA3D.createPlaneFromPoints(v0,p,v2);let plane01p=PGA3D.createPlaneFromPoints(v0,v1,p);let area012=plane012[11]*plane012[11]+plane012[12]*plane012[12]+plane012[13]*plane012[13]+plane012[14]*plane012[14];let areap12=plane012[11]*planep12[11]+plane012[12]*planep12[12]+plane012[13]*planep12[13]+plane012[14]*planep12[14];let area0p2=plane012[11]*plane0p2[11]+plane012[12]*plane0p2[12]+plane012[13]*plane0p2[13]+plane012[14]*plane0p2[14];let area01p=plane012[11]*plane01p[11]+plane012[12]*plane01p[12]+plane012[13]*plane01p[13]+plane012[14]*plane01p[14];let lambda1=areap12/area012;let lambda2=area0p2/area012;let lambda3=area01p/area012;return lambda1>=0&&lambda1<=1&&lambda2>=0&&lambda2<=1&&lambda3>=0&&lambda3<=1;}}
class Camera{constructor(width,height){this._pose=new Float32Array(Array(16).fill(0));this._pose[0]=1;this._focal=new Float32Array(Array(2).fill(1));this._resolutions=new Float32Array([width,height]);this._isProjective=true;}
resetPose(){this._pose[0]=1;for(let i=1;i<16;++i)this._pose[i]=0;this._focal[0]=1;this._focal[1]=1;}
updatePose(newpose){for(let i=0;i<16;++i)this._pose[i]=newpose[i];}
updateSize(width,height){this._resolutions[0]=width;this._resolutions[1]=height;}
moveX(d){let newdir=PGA3D.applyMotorToDir([1,0,0],this._pose);let dt=PGA3D.createTranslator(newdir[0]*d,newdir[1]*d,newdir[2]*d);let newpose=PGA3D.geometricProduct(dt,this._pose);this.updatePose(newpose);}
moveY(d){let newdir=PGA3D.applyMotorToDir([0,1,0],this._pose);let dt=PGA3D.createTranslator(newdir[0]*d,newdir[1]*d,newdir[2]*d);let newpose=PGA3D.geometricProduct(dt,this._pose);this.updatePose(newpose);}
moveZ(d){let newdir=PGA3D.applyMotorToDir([0,0,1],this._pose);let dt=PGA3D.createTranslator(newdir[0]*d,newdir[1]*d,newdir[2]*d);let newpose=PGA3D.geometricProduct(dt,this._pose);this.updatePose(newpose);}
rotateX(d,a){let newdir=PGA3D.applyMotorToDir([1,0,0],this._pose);let newstartpt=PGA3D.applyMotorToPoint([0,0,0],this._pose);let dt=PGA3D.createRotor(a,newdir[0],newdir[1],newdir[2],newstartpt[0],newstartpt[1],newstartpt[2]);let newpose=PGA3D.geometricProduct(dt,this._pose);this.updatePose(newpose);}
rotateY(d,a){let newdir=PGA3D.applyMotorToDir([0,1,0],this._pose);let newstartpt=PGA3D.applyMotorToPoint([0,0,0],this._pose);let dt=PGA3D.createRotor(a,newdir[0],newdir[1],newdir[2],newstartpt[0],newstartpt[1],newstartpt[2]);let newpose=PGA3D.geometricProduct(dt,this._pose);this.updatePose(newpose);}
rotateZ(d,a){let newdir=PGA3D.applyMotorToDir([0,0,1],this._pose);let newstartpt=PGA3D.applyMotorToPoint([0,0,0],this._pose);let dt=PGA3D.createRotor(a,newdir[0],newdir[1],newdir[2],newstartpt[0],newstartpt[1],newstartpt[2]);let newpose=PGA3D.geometricProduct(dt,this._pose);this.updatePose(newpose);}}
class Light{constructor(){this._intensity=new Float32Array(Array(4).fill(0));this._position=new Float32Array(Array(4).fill(0));this._direction=new Float32Array(Array(4).fill(0));this._attenuation=new Float32Array(Array(4).fill(0));this._attenuation[0]=1.;this._params=new Float32Array(Array(4).fill(0));}}
class PointLight extends Light{constructor(intensity=[1,1,1],position=[0,0,0],attenuation=[1,0.1,0.01]){super();for(let i=0;i<3;++i){this._intensity[i]=intensity[i];this._position[i]=position[i];this._attenuation[i]=attenuation[i];}}}
class DirectionalLight extends Light{constructor(intensity=[1,1,1],direction=[Math.sqrt(3),Math.sqrt(3),Math.sqrt(3)]){super();for(let i=0;i<3;++i){this._intensity[i]=intensity[i];this._direction[i]=direction[i];}}}
class SpotLight extends Light{constructor(intensity=[1,1,1],position=[0,0,0],direction=[0,1,0],attenuation=[1,0.1,0.01],cutoff=0.785,dropoff=5){super();for(let i=0;i<3;++i){this._intensity[i]=intensity[i];this._position[i]=position[i];this._direction[i]=direction[i];this._attenuation[i]=attenuation[i];}
this._params[0]=cutoff;this._params[1]=dropoff;}}
async function init(){const canvasTag=document.createElement('canvas');canvasTag.id="renderCanvas";document.body.appendChild(canvasTag);const tracer=new RayTracer(canvasTag);await tracer.init();var camera=new Camera();camera._pose[2]=0.5;camera._pose[3]=0.5;var tracerObj=new RayTracingBoxLightObject(tracer._device,tracer._canvasFormat,camera);await tracer.setTracerObject(tracerObj);var pointLight=new PointLight();var dirLight=new DirectionalLight();var spotLight=new SpotLight();tracerObj.updateLight(pointLight);let fps='??';var fpsText=new StandardTextObject('fps: '+fps,"10");var instructions='move camera: wasdqe\nrotate camera: ijkluo\nv/V: change shading (lambertian, phong, toon)\nc/C: change light (point, directional, spotlight)\nb/B: toggle visibility';var instructText=new StandardTextObject(instructions);var movespeed=0.05;var rotSpeed=0.1;var newFocal=new Float32Array(Array(2).fill(1));var needToWait=false;window.addEventListener("keydown",async(e)=>{switch(e.key){case'w':case'W':camera.moveY(-movespeed);tracerObj.updateCameraPose();break;case's':case'S':camera.moveY(movespeed);tracerObj.updateCameraPose();break;case'a':case'A':camera.moveX(-movespeed);tracerObj.updateCameraPose();break;case'd':case'D':camera.moveX(movespeed);tracerObj.updateCameraPose();break;case'e':case'E':camera.moveZ(movespeed);tracerObj.updateCameraPose();break;case'q':case'Q':camera.moveZ(-movespeed);tracerObj.updateCameraPose();break;case'k':case'K':camera.rotateX(movespeed,rotSpeed);tracerObj.updateCameraPose();break;case'i':case'I':camera.rotateX(-movespeed,-rotSpeed);tracerObj.updateCameraPose();break;case'l':case'L':camera.rotateY(movespeed,-rotSpeed);tracerObj.updateCameraPose();break;case'j':case'J':camera.rotateY(-movespeed,rotSpeed);tracerObj.updateCameraPose();break;case'u':case'U':camera.rotateZ(movespeed,rotSpeed);tracerObj.updateCameraPose();break;case'o':case'O':camera.rotateZ(-movespeed,-rotSpeed);tracerObj.updateCameraPose();break;case't':case'T':tracerObj.moveY(-movespeed);tracerObj.updateBoxPose();break;case'g':case'G':tracerObj.moveY(movespeed);tracerObj.updateBoxPose();break;case'f':case'F':tracerObj.moveX(-movespeed);tracerObj.updateBoxPose();break;case'h':case'H':tracerObj.moveX(movespeed);tracerObj.updateBoxPose();break;case'y':case'Y':tracerObj.moveZ(movespeed);tracerObj.updateBoxPose();break;case'r':case'R':tracerObj.moveZ(-movespeed);tracerObj.updateBoxPose();break;case'ArrowDown':tracerObj.rotateX(movespeed,rotSpeed);tracerObj.updateBoxPose();break;case'ArrowUp':tracerObj.rotateX(-movespeed,-rotSpeed);tracerObj.updateBoxPose();break;case'ArrowRight':tracerObj.rotateY(movespeed,-rotSpeed);tracerObj.updateBoxPose();break;case'ArrowLeft':tracerObj.rotateY(-movespeed,rotSpeed);tracerObj.updateBoxPose();break;case'n':case'N':tracerObj.rotateZ(movespeed,rotSpeed);tracerObj.updateBoxPose();break;case'm':case'M':tracerObj.rotateZ(-movespeed,-rotSpeed);tracerObj.updateBoxPose();break;case'[':newFocal[0]=tracerObj._camera._focal[0]+1;newFocal[1]=tracerObj._camera._focal[1];tracerObj.updateCameraFocal(newFocal);console.log(tracerObj._camera._focal);break;case']':newFocal[0]=tracerObj._camera._focal[0]-1;newFocal[1]=tracerObj._camera._focal[1];tracerObj.updateCameraFocal(newFocal);console.log(tracerObj._camera._focal);break;case'{':newFocal[0]=tracerObj._camera._focal[0];newFocal[1]=tracerObj._camera._focal[1]+1;tracerObj.updateCameraFocal(newFocal);console.log(tracerObj._camera._focal);break;case'}':newFocal[0]=tracerObj._camera._focal[0];newFocal[1]=tracerObj._camera._focal[1]-1;tracerObj.updateCameraFocal(newFocal);console.log(tracerObj._camera._focal);break;case'v':case'V':if(!needToWait){needToWait=true;const renderTypes=2;tracerObj._mode+=1;if(tracerObj._mode>renderTypes){tracerObj._mode=0;}
await tracerObj.updateMode();needToWait=false;}
break;case'c':case'C':const lightTypes=[pointLight,dirLight,spotLight];tracerObj._lightIndex+=1;if(tracerObj._lightIndex>2){tracerObj._lightIndex=0;}
tracerObj.updateLight(lightTypes[tracerObj._lightIndex]);break;case'b':case'B':fpsText.toggleVisibility();instructText.toggleVisibility();break;}});var frameCnt=0;var tgtFPS=60;var secPerFrame=1./tgtFPS;var frameInterval=secPerFrame*1000;var lastCalled;let renderFrame=()=>{let elapsed=Date.now()-lastCalled;if(elapsed>frameInterval){++frameCnt;lastCalled=Date.now()-(elapsed%frameInterval);tracer.render();}
requestAnimationFrame(renderFrame);};lastCalled=Date.now();renderFrame();setInterval(()=>{fpsText.updateText('fps: '+frameCnt);frameCnt=0;},1000);return tracer;}
init().then(ret=>{console.log(ret);}).catch(error=>{const pTag=document.createElement('p');pTag.innerHTML=navigator.userAgent+"</br>"+error.message;document.body.appendChild(pTag);document.getElementById("renderCanvas").remove();});
    </script>
    
</body>
</html>